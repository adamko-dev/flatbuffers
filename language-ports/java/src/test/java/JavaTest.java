/*
 * Copyright 2014 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import static com.google.flatbuffers.Constants.SIZE_PREFIX_LENGTH;
import static org.junit.jupiter.api.Assertions.assertArrayEquals;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

import MyGame.Example.AbilityT;
import MyGame.Example.Any;
import MyGame.Example.ArrayStruct;
import MyGame.Example.ArrayTable;
import MyGame.Example.Color;
import MyGame.Example.Monster;
import MyGame.Example.MonsterT;
import MyGame.Example.NestedStruct;
import MyGame.Example.ReferrableT;
import MyGame.Example.TestEnum;
import MyGame.Example.TestT;
import MyGame.Example.Vec3;
import MyGame.Example.Vec3T;
import NamespaceA.NamespaceB.TableInNestedNS;
import NamespaceA.TableInFirstNS;
import com.google.flatbuffers.ByteBufferUtil;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.FlexBuffers;
import com.google.flatbuffers.FlexBuffers.FlexBufferException;
import com.google.flatbuffers.FlexBuffers.KeyVector;
import com.google.flatbuffers.FlexBuffers.Reference;
import com.google.flatbuffers.FlexBuffers.Vector;
import com.google.flatbuffers.FlexBuffersBuilder;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.UnionVector;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.channels.FileChannel;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import optional_scalars.OptionalByte;
import optional_scalars.ScalarStuff;
import org.junit.jupiter.api.Test;
import union_vector.Attacker;
import union_vector.Character;
import union_vector.Movie;


class JavaTest {

  @Test
  public void test() {

    // First, let's test reading a FlatBuffer generated by C++ code:
    // This file was generated from monsterdata_test.json

    byte[] data;
    try (var file = ClassLoader.getSystemResourceAsStream("monsterdata_test.mon")) {
      data = Objects.requireNonNull(file).readAllBytes();
    } catch (IOException e) {
      throw new RuntimeException("FlatBuffers test: couldn't read file", e);
    }

    // Now test it:

    ByteBuffer bb = ByteBuffer.wrap(data);
    TestBuffer(bb);

    // Second, let's create a FlatBuffer from scratch in Java, and test it also.
    // We use an initial size of 1 to exercise the reallocation algorithm,
    // normally a size larger than the typical FlatBuffer you generate would be
    // better for performance.
    FlatBufferBuilder fbb = new FlatBufferBuilder(1);

    TestBuilderBasics(fbb, true);
    TestBuilderBasics(fbb, false);

    TestExtendedBuffer(fbb.dataBuffer().asReadOnlyBuffer());

    TestNamespaceNesting();

    TestNestedFlatBuffer();

    TestCreateByteVector();

    TestCreateUninitializedVector();

    TestByteBufferFactory();

    TestSizedInputStream();

    TestVectorOfUnions();

    TestFixedLengthArrays();

    TestFlexBuffers();

    TestVectorOfBytes();

    TestSharedStringPool();

    TestScalarOptional();

    TestPackUnpack(bb);

    System.out.println("FlatBuffers test: completed successfully");
  }

  @Test
  void TestEnums() {
    assertEquals(Color.name(Color.Red), "Red");
    assertEquals(Color.name(Color.Blue), "Blue");
    assertEquals(Any.name(Any.NONE), "NONE");
    assertEquals(Any.name(Any.Monster), "Monster");
  }

  void TestBuffer(ByteBuffer bb) {
    assertTrue(Monster.MonsterBufferHasIdentifier(bb));

    Monster monster = Monster.getRootAsMonster(bb);

    assertEquals(monster.hp(), (short) 80);
    assertEquals(monster.mana(), (short) 150);  // default

    assertEquals(monster.name(), "MyMonster");
    // monster.friendly() // can't access, deprecated

    Vec3 pos = monster.pos();
    assertEquals(pos.x(), 1.0f);
    assertEquals(pos.y(), 2.0f);
    assertEquals(pos.z(), 3.0f);
    assertEquals(pos.test1(), 3.0);
    // issue: int != byte
    assertEquals(pos.test2(), Color.Green);
    MyGame.Example.Test t = pos.test3();
    assertEquals(t.a(), (short) 5);
    assertEquals(t.b(), (byte) 6);

    assertEquals(monster.testType(), Any.Monster);
    Monster monster2 = new Monster();
    assertNotNull(monster.test(monster2));
    assertEquals(monster2.name(), "Fred");

    assertEquals(monster.inventoryLength(), 5);
    int invsum = 0;
    for (int i = 0; i < monster.inventoryLength(); i++) {
      invsum += monster.inventory(i);
    }
    assertEquals(invsum, 10);

    // Method using a vector access object:
    ByteVector inventoryVector = monster.inventoryVector();
    assertEquals(inventoryVector.length(), 5);
    invsum = 0;
    for (int i = 0; i < inventoryVector.length(); i++) {
      invsum += inventoryVector.getAsUnsigned(i);
    }
    assertEquals(invsum, 10);

    // Alternative way of accessing a vector:
    ByteBuffer ibb = monster.inventoryAsByteBuffer();
    invsum = 0;
    while (ibb.position() < ibb.limit()) {
      invsum += ibb.get();
    }
    assertEquals(invsum, 10);

    MyGame.Example.Test test_0 = monster.test4(0);
    MyGame.Example.Test test_1 = monster.test4(1);
    assertEquals(monster.test4Length(), 2);
    assertEquals(test_0.a() + test_0.b() + test_1.a() + test_1.b(), 100);

    MyGame.Example.Test.Vector test4Vector = monster.test4Vector();
    test_0 = test4Vector.get(0);
    test_1 = test4Vector.get(1);
    assertEquals(test4Vector.length(), 2);
    assertEquals(test_0.a() + test_0.b() + test_1.a() + test_1.b(), 100);

    assertEquals(monster.testarrayofstringLength(), 2);
    assertEquals(monster.testarrayofstring(0), "test1");
    assertEquals(monster.testarrayofstring(1), "test2");

    // Method using a vector access object:
    StringVector testarrayofstringVector = monster.testarrayofstringVector();
    assertEquals(testarrayofstringVector.length(), 2);
    assertEquals(testarrayofstringVector.get(0), "test1");
    assertEquals(testarrayofstringVector.get(1), "test2");

    assertTrue(monster.testbool());
  }

  /**
   * This method checks additional fields not present in the binary buffer read from file
   * these new tests are performed on top of the regular tests
   */
  void TestExtendedBuffer(ByteBuffer bb) {
    TestBuffer(bb);

    Monster monster = Monster.getRootAsMonster(bb);

    assertEquals(monster.testhashu32Fnv1(), Integer.MAX_VALUE + 1L);
  }

  @Test
  void TestNamespaceNesting() {
    // reference / manipulate these to verify compilation
    FlatBufferBuilder fbb = new FlatBufferBuilder(1);

    TableInNestedNS.startTableInNestedNS(fbb);
    TableInNestedNS.addFoo(fbb, 1234);
    int nestedTableOff = TableInNestedNS.endTableInNestedNS(fbb);

    TableInFirstNS.startTableInFirstNS(fbb);
    TableInFirstNS.addFooTable(fbb, nestedTableOff);
    int off = TableInFirstNS.endTableInFirstNS(fbb);
    // TODO add assertions to this test
  }

  @Test
  void TestNestedFlatBuffer() {
    final String nestedMonsterName = "NestedMonsterName";
    final short nestedMonsterHp = 600;
    final short nestedMonsterMana = 1024;

    FlatBufferBuilder fbb1 = new FlatBufferBuilder(16);
    int str1 = fbb1.createString(nestedMonsterName);
    Monster.startMonster(fbb1);
    Monster.addName(fbb1, str1);
    Monster.addHp(fbb1, nestedMonsterHp);
    Monster.addMana(fbb1, nestedMonsterMana);
    int monster1 = Monster.endMonster(fbb1);
    Monster.finishMonsterBuffer(fbb1, monster1);
    byte[] fbb1Bytes = fbb1.sizedByteArray();

    FlatBufferBuilder fbb2 = new FlatBufferBuilder(16);
    int str2 = fbb2.createString("My Monster");
    int nestedBuffer = Monster.createTestnestedflatbufferVector(fbb2, fbb1Bytes);
    Monster.startMonster(fbb2);
    Monster.addName(fbb2, str2);
    Monster.addHp(fbb2, (short) 50);
    Monster.addMana(fbb2, (short) 32);
    Monster.addTestnestedflatbuffer(fbb2, nestedBuffer);
    int monster = Monster.endMonster(fbb2);
    Monster.finishMonsterBuffer(fbb2, monster);

    // Now test the data extracted from the nested buffer
    Monster mons = Monster.getRootAsMonster(fbb2.dataBuffer());
    Monster nestedMonster = mons.testnestedflatbufferAsMonster();

    assertEquals(nestedMonsterMana, nestedMonster.mana());
    assertEquals(nestedMonsterHp, nestedMonster.hp());
    assertEquals(nestedMonsterName, nestedMonster.name());
  }

  @Test
  void TestCreateByteVector() {
    FlatBufferBuilder fbb = new FlatBufferBuilder(16);
    int str = fbb.createString("MyMonster");
    byte[] inventory = new byte[]{0, 1, 2, 3, 4};
    int vec = fbb.createByteVector(inventory);
    Monster.startMonster(fbb);
    Monster.addInventory(fbb, vec);
    Monster.addName(fbb, str);
    int monster1 = Monster.endMonster(fbb);
    Monster.finishMonsterBuffer(fbb, monster1);
    Monster monsterObject = Monster.getRootAsMonster(fbb.dataBuffer());

    assertEquals(monsterObject.inventory(1), inventory[1]);
    assertEquals(monsterObject.inventoryLength(), inventory.length);
    ByteVector inventoryVector = monsterObject.inventoryVector();
    assertEquals(inventoryVector.getAsUnsigned(1), inventory[1]);
    assertEquals(inventoryVector.length(), inventory.length);

    assertEquals(ByteBuffer.wrap(inventory), monsterObject.inventoryAsByteBuffer());
  }

  @Test
  void TestCreateUninitializedVector() {
    FlatBufferBuilder fbb = new FlatBufferBuilder(16);
    int str = fbb.createString("MyMonster");
    byte[] inventory = new byte[]{0, 1, 2, 3, 4};
    ByteBuffer bb = fbb.createUnintializedVector(1, inventory.length, 1);
    for (byte i : inventory) {
      bb.put(i);
    }
    int vec = fbb.endVector();
    Monster.startMonster(fbb);
    Monster.addInventory(fbb, vec);
    Monster.addName(fbb, str);
    int monster1 = Monster.endMonster(fbb);
    Monster.finishMonsterBuffer(fbb, monster1);
    Monster monsterObject = Monster.getRootAsMonster(fbb.dataBuffer());

    assertEquals(monsterObject.inventory(1), inventory[1]);
    assertEquals(monsterObject.inventoryLength(), inventory.length);
    ByteVector inventoryVector = monsterObject.inventoryVector();
    assertEquals(inventoryVector.getAsUnsigned(1), inventory[1]);
    assertEquals(inventoryVector.length(), inventory.length);
    assertEquals(ByteBuffer.wrap(inventory), monsterObject.inventoryAsByteBuffer());
  }

  @Test
  void TestByteBufferFactory() {
    final class MappedByteBufferFactory extends FlatBufferBuilder.ByteBufferFactory {

      @Override
      public ByteBuffer newByteBuffer(int capacity) {
        ByteBuffer bb;
        try {
          RandomAccessFile f = new RandomAccessFile("javatest.bin", "rw");
          bb = f.getChannel().map(FileChannel.MapMode.READ_WRITE, 0, capacity)
            .order(ByteOrder.LITTLE_ENDIAN);
          f.close();
        } catch (Throwable e) {
          System.out.println("FlatBuffers test: couldn't map ByteBuffer to a file");
          bb = null;
        }
        return bb;
      }
    }

    FlatBufferBuilder fbb = new FlatBufferBuilder(1, new MappedByteBufferFactory());

    TestBuilderBasics(fbb, false);
  }

  @Test
  void TestSizedInputStream() {
    // Test on default FlatBufferBuilder that uses HeapByteBuffer
    FlatBufferBuilder fbb = new FlatBufferBuilder(1);

    TestBuilderBasics(fbb, false);

    InputStream in = fbb.sizedInputStream();
    byte[] array = fbb.sizedByteArray();
    int count = 0;
    int currentVal = 0;

    while (currentVal != -1 && count < array.length) {
      try {
        currentVal = in.read();
      } catch (IOException e) {
        System.out.println("FlatBuffers test: couldn't read from InputStream");
        return;
      }
      assertEquals((byte) currentVal, array[count]);
      count++;
    }
    assertEquals(count, array.length);
  }

  void TestBuilderBasics(FlatBufferBuilder fbb, boolean sizePrefix) {
    int[] names = {fbb.createString("Frodo"), fbb.createString("Barney"),
      fbb.createString("Wilma")};
    int[] off = new int[3];
    Monster.startMonster(fbb);
    Monster.addName(fbb, names[0]);
    off[0] = Monster.endMonster(fbb);
    Monster.startMonster(fbb);
    Monster.addName(fbb, names[1]);
    off[1] = Monster.endMonster(fbb);
    Monster.startMonster(fbb);
    Monster.addName(fbb, names[2]);
    off[2] = Monster.endMonster(fbb);
    int sortMons = fbb.createSortedVectorOfTables(new Monster(), off);

    // We set up the same values as monsterdata.json:

    int str = fbb.createString("MyMonster");

    int inv = Monster.createInventoryVector(fbb, new byte[]{0, 1, 2, 3, 4});

    int fred = fbb.createString("Fred");
    Monster.startMonster(fbb);
    Monster.addName(fbb, fred);
    int mon2 = Monster.endMonster(fbb);

    Monster.startTest4Vector(fbb, 2);
    MyGame.Example.Test.createTest(fbb, (short) 10, (byte) 20);
    MyGame.Example.Test.createTest(fbb, (short) 30, (byte) 40);
    int test4 = fbb.endVector();

    int testArrayOfString = Monster.createTestarrayofstringVector(fbb, new int[]{
      fbb.createString("test1"),
      fbb.createString("test2")
    });

    Monster.startMonster(fbb);
    Monster.addPos(fbb, Vec3.createVec3(fbb, 1.0f, 2.0f, 3.0f, 3.0,
      Color.Green, (short) 5, (byte) 6));
    Monster.addHp(fbb, (short) 80);
    Monster.addName(fbb, str);
    Monster.addInventory(fbb, inv);
    Monster.addTestType(fbb, Any.Monster);
    Monster.addTest(fbb, mon2);
    Monster.addTest4(fbb, test4);
    Monster.addTestarrayofstring(fbb, testArrayOfString);
    Monster.addTestbool(fbb, true);
    Monster.addTesthashu32Fnv1(fbb, Integer.MAX_VALUE + 1L);
    Monster.addTestarrayoftables(fbb, sortMons);
    int mon = Monster.endMonster(fbb);

    if (sizePrefix) {
      Monster.finishSizePrefixedMonsterBuffer(fbb, mon);
    } else {
      Monster.finishMonsterBuffer(fbb, mon);
    }

    // Write the result to a file for debugging purposes:
    // Note that the binaries are not necessarily identical, since the JSON
    // parser may serialize in a slightly different order than the above
    // Java code. They are functionally equivalent though.

    try {
      String filename = "monsterdata_java_wire" + (sizePrefix ? "_sp" : "") + ".mon";
      FileChannel fc = new FileOutputStream(filename).getChannel();
      fc.write(fbb.dataBuffer().duplicate());
      fc.close();
    } catch (IOException e) {
      System.out.println("FlatBuffers test: couldn't write file");
      return;
    }

    // Test it:
    ByteBuffer dataBuffer = fbb.dataBuffer();
    if (sizePrefix) {
      assertEquals(ByteBufferUtil.getSizePrefix(dataBuffer) + SIZE_PREFIX_LENGTH,
        dataBuffer.remaining());
      dataBuffer = ByteBufferUtil.removeSizePrefix(dataBuffer);
    }
    TestExtendedBuffer(dataBuffer);

    // Make sure it also works with read only ByteBuffers. This is slower,
    // since creating strings incurs an additional copy
    // (see Table.__string).
    TestExtendedBuffer(dataBuffer.asReadOnlyBuffer());

    TestEnums();

    //Attempt to mutate Monster fields and check whether the buffer has been mutated properly
    // revert to original values after testing
    Monster monster = Monster.getRootAsMonster(dataBuffer);

    // mana is optional and does not exist in the buffer so the mutation should fail
    // the mana field should retain its default value
    assertFalse(monster.mutateMana((short) 10));
    assertEquals(monster.mana(), (short) 150);

    // Accessing a vector of sorted by the key tables
    assertEquals(monster.testarrayoftables(0).name(), "Barney");
    assertEquals(monster.testarrayoftables(1).name(), "Frodo");
    assertEquals(monster.testarrayoftables(2).name(), "Wilma");
    Monster.Vector testarrayoftablesVector = monster.testarrayoftablesVector();
    assertEquals(testarrayoftablesVector.get(0).name(), "Barney");
    assertEquals(testarrayoftablesVector.get(1).name(), "Frodo");
    assertEquals(testarrayoftablesVector.get(2).name(), "Wilma");

    // Example of searching for a table by the key
    assertEquals(monster.testarrayoftablesByKey("Frodo").name(), "Frodo");
    assertEquals(monster.testarrayoftablesByKey("Barney").name(), "Barney");
    assertEquals(monster.testarrayoftablesByKey("Wilma").name(), "Wilma");
    assertEquals(testarrayoftablesVector.getByKey("Frodo").name(), "Frodo");
    assertEquals(testarrayoftablesVector.getByKey("Barney").name(), "Barney");
    assertEquals(testarrayoftablesVector.getByKey("Wilma").name(), "Wilma");

    // testType is an existing field and mutating it should succeed
    assertEquals(monster.testType(), Any.Monster);

    //mutate the inventory vector
    assertTrue(monster.mutateInventory(0, 1));
    assertTrue(monster.mutateInventory(1, 2));
    assertTrue(monster.mutateInventory(2, 3));
    assertTrue(monster.mutateInventory(3, 4));
    assertTrue(monster.mutateInventory(4, 5));

    for (int i = 0; i < monster.inventoryLength(); i++) {
      assertEquals(monster.inventory(i), i + 1);
    }
    ByteVector inventoryVector = monster.inventoryVector();
    for (int i = 0; i < inventoryVector.length(); i++) {
      assertEquals(inventoryVector.get(i), i + 1);
    }

    //reverse mutation
    assertTrue(monster.mutateInventory(0, 0));
    assertTrue(monster.mutateInventory(1, 1));
    assertTrue(monster.mutateInventory(2, 2));
    assertTrue(monster.mutateInventory(3, 3));
    assertTrue(monster.mutateInventory(4, 4));

    // get a struct field and edit one of its fields
    Vec3 pos = monster.pos();
    assertEquals(pos.x(), 1.0f);
    pos.mutateX(55.0f);
    assertEquals(pos.x(), 55.0f);
    pos.mutateX(1.0f);
    assertEquals(pos.x(), 1.0f);
  }

  @Test
  void TestVectorOfUnions() {
    final FlatBufferBuilder fbb = new FlatBufferBuilder();

    final int swordAttackDamage = 1;

    final int[] characterVector = new int[]{
      Attacker.createAttacker(fbb, swordAttackDamage),
    };

    final byte[] characterTypeVector = new byte[]{
      Character.MuLan,
    };

    Movie.finishMovieBuffer(
      fbb,
      Movie.createMovie(
        fbb,
        (byte) 0,
        (byte) 0,
        Movie.createCharactersTypeVector(fbb, characterTypeVector),
        Movie.createCharactersVector(fbb, characterVector)
      )
    );

    final Movie movie = Movie.getRootAsMovie(fbb.dataBuffer());
    ByteVector charactersTypeByteVector = movie.charactersTypeVector();
    UnionVector charactersVector = movie.charactersVector();

    assertEquals(movie.charactersTypeLength(), characterTypeVector.length);
    assertEquals(charactersTypeByteVector.length(), characterTypeVector.length);
    assertEquals(movie.charactersLength(), characterVector.length);
    assertEquals(charactersVector.length(), characterVector.length);

    assertEquals(movie.charactersType(0), characterTypeVector[0]);
    assertEquals(charactersTypeByteVector.get(0), characterTypeVector[0]);

    assertEquals(((Attacker) movie.characters(new Attacker(), 0)).swordAttackDamage(),
      swordAttackDamage);
  }

  @Test
  void TestFixedLengthArrays() {
    FlatBufferBuilder builder = new FlatBufferBuilder(0);

    float a;
    int[] b = new int[15];
    byte c;
    int[][] d_a = new int[2][2];
    byte[] d_b = new byte[2];
    byte[][] d_c = new byte[2][2];
    long[][] d_d = new long[2][2];
    int e;
    long[] f = new long[2];

    a = 0.5f;
    for (int i = 0; i < 15; i++) {
      b[i] = i;
    }
    c = 1;
    d_a[0][0] = 1;
    d_a[0][1] = 2;
    d_a[1][0] = 3;
    d_a[1][1] = 4;
    d_b[0] = TestEnum.B;
    d_b[1] = TestEnum.C;
    d_c[0][0] = TestEnum.A;
    d_c[0][1] = TestEnum.B;
    d_c[1][0] = TestEnum.C;
    d_c[1][1] = TestEnum.B;
    d_d[0][0] = -1;
    d_d[0][1] = 1;
    d_d[1][0] = -2;
    d_d[1][1] = 2;
    e = 2;
    f[0] = -1;
    f[1] = 1;

    int arrayOffset = ArrayStruct.createArrayStruct(builder,
      a, b, c, d_a, d_b, d_c, d_d, e, f);

    // Create a table with the ArrayStruct.
    ArrayTable.startArrayTable(builder);
    ArrayTable.addA(builder, arrayOffset);
    int tableOffset = ArrayTable.endArrayTable(builder);

    ArrayTable.finishArrayTableBuffer(builder, tableOffset);

    ArrayTable table = ArrayTable.getRootAsArrayTable(builder.dataBuffer());
    NestedStruct nested = new NestedStruct();

    assertEquals(table.a().a(), 0.5f);
    for (int i = 0; i < 15; i++) {
      assertEquals(table.a().b(i), i);
    }
    assertEquals(table.a().c(), (byte) 1);
    assertEquals(table.a().d(nested, 0).a(0), 1);
    assertEquals(table.a().d(nested, 0).a(1), 2);
    assertEquals(table.a().d(nested, 1).a(0), 3);
    assertEquals(table.a().d(nested, 1).a(1), 4);
    assertEquals(table.a().d(nested, 0).b(), TestEnum.B);
    assertEquals(table.a().d(nested, 1).b(), TestEnum.C);
    assertEquals(table.a().d(nested, 0).c(0), TestEnum.A);
    assertEquals(table.a().d(nested, 0).c(1), TestEnum.B);
    assertEquals(table.a().d(nested, 1).c(0), TestEnum.C);
    assertEquals(table.a().d(nested, 1).c(1), TestEnum.B);
    assertEquals(table.a().d(nested, 0).d(0), -1);
    assertEquals(table.a().d(nested, 0).d(1), 1);
    assertEquals(table.a().d(nested, 1).d(0), -2);
    assertEquals(table.a().d(nested, 1).d(1), 2);
    assertEquals(table.a().e(), 2);
    assertEquals(table.a().f(0), -1);
    assertEquals(table.a().f(1), 1);
  }

  @Test
  public void testFlexBuffersTest() {
    FlexBuffersBuilder builder = new FlexBuffersBuilder(ByteBuffer.allocate(512),
      FlexBuffersBuilder.BUILDER_FLAG_SHARE_KEYS_AND_STRINGS);
    testFlexBuffersTest(builder);
    int bufferLimit1 = builder.getBuffer().limit();

    // Repeat after clearing the builder to ensure the builder is reusable
    builder.clear();
    testFlexBuffersTest(builder);
    int bufferLimit2 = builder.getBuffer().limit();
    assertEquals(bufferLimit1, bufferLimit2);
  }

  public void testFlexBuffersTest(FlexBuffersBuilder builder) {
    // Write the equivalent of:
    // { vec: [ -100, "Fred", 4.0, false ], bar: [ 1, 2, 3 ], bar3: [ 1, 2, 3 ],
    // foo: 100, bool: true, mymap: { foo: "Fred" } }
    // It's possible to do this without std::function support as well.
    int map1 = builder.startMap();

    int vec1 = builder.startVector();
    builder.putInt(-100);
    builder.putString("Fred");
    builder.putBlob(new byte[]{(byte) 77});
    builder.putBoolean(false);
    builder.putInt(Long.MAX_VALUE);

    int map2 = builder.startMap();
    builder.putInt("test", 200);
    builder.endMap(null, map2);

    builder.putFloat(150.9);
    builder.putFloat(150.9999998);
    builder.endVector("vec", vec1, false, false);

    vec1 = builder.startVector();
    builder.putInt(1);
    builder.putInt(2);
    builder.putInt(3);
    builder.endVector("bar", vec1, true, false);

    vec1 = builder.startVector();
    builder.putBoolean(true);
    builder.putBoolean(false);
    builder.putBoolean(true);
    builder.putBoolean(false);
    builder.endVector("bools", vec1, true, false);

    builder.putBoolean("bool", true);
    builder.putFloat("foo", 100);

    map2 = builder.startMap();
    builder.putString("bar", "Fred");  // Testing key and string reuse.
    builder.putInt("int", -120);
    builder.putFloat("float", -123.0f);
    builder.putBlob("blob", new byte[]{65, 67});
    builder.endMap("mymap", map2);

    builder.endMap(null, map1);
    builder.finish();

    FlexBuffers.Map m = FlexBuffers.getRoot(builder.getBuffer()).asMap();

    assertEquals(m.size(), 6);

    // test empty (an null)
    assertEquals(m.get("no_key").asString(), ""); // empty if fail
    assertEquals(m.get("no_key").asMap(), FlexBuffers.Map.empty()); // empty if fail
    assertEquals(m.get("no_key").asKey(), FlexBuffers.Key.empty()); // empty if fail
    assertEquals(m.get("no_key").asVector(), FlexBuffers.Vector.empty()); // empty if fail
    assertEquals(m.get("no_key").asBlob(), FlexBuffers.Blob.empty()); // empty if fail
    assertTrue(m.get("no_key").asVector().isEmpty()); // empty if fail

    // testing "vec" field
    FlexBuffers.Vector vec = m.get("vec").asVector();
    assertEquals(vec.size(), 8);
    assertEquals(vec.get(0).asLong(), -100);
    assertEquals(vec.get(1).asString(), "Fred");
    assertTrue(vec.get(2).isBlob());
    assertEquals(vec.get(2).asBlob().size(), 1);
    assertEquals(vec.get(2).asBlob().data().get(0), (byte) 77);
    assertTrue(vec.get(3).isBoolean());   // Check if type is a bool
    assertFalse(vec.get(3).asBoolean());  // Check if value is false
    assertEquals(vec.get(4).asLong(), Long.MAX_VALUE);
    assertTrue(vec.get(5).isMap());
    assertEquals(vec.get(5).asMap().get("test").asInt(), 200);
    assertEquals(Float.compare((float) vec.get(6).asFloat(), 150.9f), 0);
    assertEquals(Double.compare(vec.get(7).asFloat(), 150.9999998), 0);
    assertEquals(0, vec.get(1).asLong()); //conversion fail returns 0 as C++

    // bar vector
    FlexBuffers.Vector tvec = m.get("bar").asVector();
    assertEquals(tvec.size(), 3);
    assertEquals(tvec.get(0).asInt(), 1);
    assertEquals(tvec.get(1).asInt(), 2);
    assertEquals(tvec.get(2).asInt(), 3);
    assertEquals(((FlexBuffers.TypedVector) tvec).getElemType(), FlexBuffers.FBT_INT);

    // bools vector
    FlexBuffers.Vector bvec = m.get("bools").asVector();
    assertEquals(bvec.size(), 4);
    assertTrue(bvec.get(0).asBoolean());
    assertFalse(bvec.get(1).asBoolean());
    assertTrue(bvec.get(2).asBoolean());
    assertFalse(bvec.get(3).asBoolean());
    assertEquals(((FlexBuffers.TypedVector) bvec).getElemType(), FlexBuffers.FBT_BOOL);

    assertEquals((float) m.get("foo").asFloat(), (float) 100);
    assertTrue(m.get("unknown").isNull());

    // mymap vector
    FlexBuffers.Map mymap = m.get("mymap").asMap();
    assertEquals(mymap.keys().get(0), m.keys()
      .get(0)); // These should be equal by pointer equality, since key and value are shared.
    assertEquals(mymap.keys().get(0).toString(), "bar");
    assertEquals(mymap.values().get(0).asString(), vec.get(1).asString());
    assertEquals(mymap.get("int").asInt(), -120);
    assertEquals((float) mymap.get("float").asFloat(), -123.0f);
    assertArrayEquals(mymap.get("blob").asBlob().getBytes(), new byte[]{65, 67});
    assertEquals(mymap.get("blob").asBlob().toString(), "AC");
    assertEquals(mymap.get("blob").toString(), "\"AC\"");
  }

  @Test
  public void testFlexBufferVectorStrings() {
    FlexBuffersBuilder builder = new FlexBuffersBuilder(ByteBuffer.allocate(10000000));

    int size = 3000;

    String text = "a".repeat(size);
    assertEquals(text.length(), size);

    int pos = builder.startVector();

    for (int i = 0; i < size; i++) {
      builder.putString(text);
    }

    assertThrows(
      FlexBufferException.class,
      () -> builder.endVector(null, pos, true, false),
      "this should raise an exception as typed vector of string was deprecated"
    );

    // we finish the vector again as non-typed
    builder.endVector(null, pos, false, false);

    ByteBuffer b = builder.finish();
    Vector v = FlexBuffers.getRoot(b).asVector();

    assertEquals(v.size(), size);
    for (int i = 0; i < size; i++) {
      assertEquals(v.get(i).asString().length(), size);
      assertEquals(v.get(i).asString(), text);
    }
  }

  @Test
  public void testDeprecatedTypedVectorString() {
    // tests whether we are able to support reading deprecated typed vector string
    // data is equivalent to [ "abc", "abc", "abc", "abc"]
    byte[] data = new byte[]{0x03, 0x61, 0x62, 0x63, 0x00, 0x03, 0x61, 0x62, 0x63, 0x00,
      0x03, 0x61, 0x62, 0x63, 0x00, 0x03, 0x61, 0x62, 0x63, 0x00, 0x04, 0x14, 0x10,
      0x0c, 0x08, 0x04, 0x3c, 0x01};
    Reference ref = FlexBuffers.getRoot(ByteBuffer.wrap(data));
    assertEquals(ref.getType(), FlexBuffers.FBT_VECTOR_STRING_DEPRECATED);
    assertTrue(ref.isTypedVector());
    Vector vec = ref.asVector();
    for (int i = 0; i < vec.size(); i++) {
      assertEquals("abc", vec.get(i).asString());
    }
  }

  @Test
  public void testSingleElementBoolean() {
    FlexBuffersBuilder builder = new FlexBuffersBuilder(ByteBuffer.allocate(100));
    builder.putBoolean(true);
    ByteBuffer b = builder.finish();
    assertTrue(FlexBuffers.getRoot(b).asBoolean());
  }

  @Test
  public void testSingleElementByte() {
    FlexBuffersBuilder builder = new FlexBuffersBuilder();
    builder.putInt(10);
    ByteBuffer b = builder.finish();
    assertEquals(10, FlexBuffers.getRoot(b).asInt());
  }

  @Test
  public void testSingleElementShort() {
    FlexBuffersBuilder builder = new FlexBuffersBuilder();
    builder.putInt(Short.MAX_VALUE);
    ByteBuffer b = builder.finish();
    assertEquals(Short.MAX_VALUE, (short) FlexBuffers.getRoot(b).asInt());
  }

  @Test
  public void testSingleElementInt() {
    FlexBuffersBuilder builder = new FlexBuffersBuilder();
    builder.putInt(Integer.MIN_VALUE);
    ByteBuffer b = builder.finish();
    assertEquals(Integer.MIN_VALUE, FlexBuffers.getRoot(b).asInt());
  }

  @Test
  public void testSingleElementLong() {
    FlexBuffersBuilder builder = new FlexBuffersBuilder();
    builder.putInt(Long.MAX_VALUE);
    ByteBuffer b = builder.finish();
    assertEquals(Long.MAX_VALUE, FlexBuffers.getRoot(b).asLong());
  }

  @Test
  public void testSingleElementFloat() {
    FlexBuffersBuilder builder = new FlexBuffersBuilder();
    builder.putFloat(Float.MAX_VALUE);
    ByteBuffer b = builder.finish();
    assertEquals(Float.compare(Float.MAX_VALUE, (float) FlexBuffers.getRoot(b).asFloat()), 0);
  }

  @Test
  public void testSingleElementDouble() {
    FlexBuffersBuilder builder = new FlexBuffersBuilder();
    builder.putFloat(Double.MAX_VALUE);
    ByteBuffer b = builder.finish();
    assertEquals(Double.compare(Double.MAX_VALUE, FlexBuffers.getRoot(b).asFloat()), 0);
  }

  @Test
  public void testSingleElementBigString() {
    FlexBuffersBuilder builder = new FlexBuffersBuilder(ByteBuffer.allocate(10000));
    StringBuilder sb = new StringBuilder();

    sb.append("a".repeat(3000));

    builder.putString(sb.toString());
    ByteBuffer b = builder.finish();

    FlexBuffers.Reference r = FlexBuffers.getRoot(b);

    assertEquals(FlexBuffers.FBT_STRING, r.getType());
    assertEquals(sb.toString(), r.asString());
  }

  @Test
  public void testSingleElementSmallString() {
    FlexBuffersBuilder builder = new FlexBuffersBuilder(ByteBuffer.allocate(10000));

    builder.putString("aa");
    ByteBuffer b = builder.finish();
    FlexBuffers.Reference r = FlexBuffers.getRoot(b);

    assertEquals(FlexBuffers.FBT_STRING, r.getType());
    assertEquals("aa", r.asString());
  }

  @Test
  public void testSingleElementBlob() {
    FlexBuffersBuilder builder = new FlexBuffersBuilder();
    builder.putBlob(new byte[]{5, 124, 118, -1});
    ByteBuffer b = builder.finish();
    FlexBuffers.Reference r = FlexBuffers.getRoot(b);
    byte[] result = r.asBlob().getBytes();
    assertEquals((byte) 5, result[0]);
    assertEquals((byte) 124, result[1]);
    assertEquals((byte) 118, result[2]);
    assertEquals((byte) -1, result[3]);
  }

  @Test
  public void testSingleElementLongBlob() {

    // verifies blobs of up to 2^16 in length
    for (int i = 2; i <= 1 << 16; i = i << 1) {
      byte[] input = new byte[i - 1];
      for (int index = 0; index < input.length; index++) {
        input[index] = (byte) (index % 64);
      }

      FlexBuffersBuilder builder = new FlexBuffersBuilder();
      builder.putBlob(input);
      ByteBuffer b = builder.finish();
      FlexBuffers.Reference r = FlexBuffers.getRoot(b);
      byte[] result = r.asBlob().getBytes();

      for (int index = 0; index < input.length; index++) {
        assertEquals((byte) (index % 64), result[index]);
      }
    }
  }

  @Test
  public void testSingleElementUByte() {
    FlexBuffersBuilder builder = new FlexBuffersBuilder();
    builder.putUInt(0xFF);
    ByteBuffer b = builder.finish();
    FlexBuffers.Reference r = FlexBuffers.getRoot(b);
    assertEquals(255, (int) r.asUInt());
  }

  @Test
  public void testSingleElementUShort() {
    FlexBuffersBuilder builder = new FlexBuffersBuilder();
    builder.putUInt(0xFFFF);
    ByteBuffer b = builder.finish();
    FlexBuffers.Reference r = FlexBuffers.getRoot(b);
    assertEquals(65535, (int) r.asUInt());
  }

  @Test
  public void testSingleElementUInt() {
    FlexBuffersBuilder builder = new FlexBuffersBuilder();
    builder.putUInt(0xFFFF_FFFFL);
    ByteBuffer b = builder.finish();
    FlexBuffers.Reference r = FlexBuffers.getRoot(b);
    assertEquals(4294967295L, r.asUInt());
  }

  @Test
  public void testSingleFixedTypeVector() {

    int[] ints = new int[]{5, 124, 118, -1};
    float[] floats = new float[]{5.5f, 124.124f, 118.118f, -1.1f};
    String[] strings = new String[]{"This", "is", "a", "typed", "array"};
    boolean[] booleans = new boolean[]{false, true, true, false};

    FlexBuffersBuilder builder = new FlexBuffersBuilder(ByteBuffer.allocate(512),
      FlexBuffersBuilder.BUILDER_FLAG_NONE);

    int mapPos = builder.startMap();

    int vecPos = builder.startVector();
    for (final int i : ints) {
      builder.putInt(i);
    }
    builder.endVector("ints", vecPos, true, false);

    vecPos = builder.startVector();
    for (final float i : floats) {
      builder.putFloat(i);
    }
    builder.endVector("floats", vecPos, true, false);

    vecPos = builder.startVector();
    for (final boolean i : booleans) {
      builder.putBoolean(i);
    }
    builder.endVector("booleans", vecPos, true, false);

    builder.endMap(null, mapPos);

    ByteBuffer b = builder.finish();
    FlexBuffers.Reference r = FlexBuffers.getRoot(b);
    assertTrue(r.asMap().get("ints").isTypedVector());
    assertTrue(r.asMap().get("floats").isTypedVector());
    assertTrue(r.asMap().get("booleans").isTypedVector());
  }

  @Test
  public void testSingleElementVector() {
    FlexBuffersBuilder b = new FlexBuffersBuilder();

    int vecPos = b.startVector();
    b.putInt(99);
    b.putString("wow");
    int vecpos2 = b.startVector();
    b.putInt(99);
    b.putString("wow");
    b.endVector(null, vecpos2, false, false);
    b.endVector(null, vecPos, false, false);
    b.finish();

    FlexBuffers.Reference r = FlexBuffers.getRoot(b.getBuffer());
    assertEquals(FlexBuffers.FBT_VECTOR, r.getType());
    FlexBuffers.Vector vec = FlexBuffers.getRoot(b.getBuffer()).asVector();
    assertEquals(3, vec.size());
    assertEquals(99, vec.get(0).asInt());
    assertEquals("wow", vec.get(1).asString());
    assertEquals("[ 99, \"wow\" ]", vec.get(2).toString());
    assertEquals("[ 99, \"wow\", [ 99, \"wow\" ] ]", FlexBuffers.getRoot(b.getBuffer()).toString());
  }

  @Test
  public void testSingleElementMap() {
    FlexBuffersBuilder b = new FlexBuffersBuilder();

    int mapPost = b.startMap();
    b.putInt("myInt", 0x7fffffbbbfffffffL);
    b.putString("myString", "wow");
    b.putString("myString2", "incredible");
    int start = b.startVector();
    b.putInt(99);
    b.putString("wow");
    b.endVector("myVec", start, false, false);

    b.putFloat("double", 0x1.ffffbbbffffffP+1023);
    b.endMap(null, mapPost);
    b.finish();

    FlexBuffers.Reference r = FlexBuffers.getRoot(b.getBuffer());
    assertEquals(FlexBuffers.FBT_MAP, r.getType());
    FlexBuffers.Map map = FlexBuffers.getRoot(b.getBuffer()).asMap();
    assertEquals(5, map.size());
    assertEquals(0x7fffffbbbfffffffL, map.get("myInt").asLong());
    assertEquals("wow", map.get("myString").asString());
    assertEquals("incredible", map.get("myString2").asString());
    assertEquals(99, map.get("myVec").asVector().get(0).asInt());
    assertEquals("wow", map.get("myVec").asVector().get(1).asString());
    assertEquals(Double.compare(0x1.ffffbbbffffffP+1023, map.get("double").asFloat()), 0);
    assertEquals(
      "{ \"double\" : 1.7976894783391937E308, \"myInt\" : 9223371743723257855, \"myString\" : \"wow\", \"myString2\" : \"incredible\", \"myVec\" : [ 99, \"wow\" ] }",
      FlexBuffers.getRoot(b.getBuffer()).toString());
  }

  @Test
  public void testFlexBuferEmpty() {
    FlexBuffers.Blob blob = FlexBuffers.Blob.empty();
    FlexBuffers.Map ary = FlexBuffers.Map.empty();
    FlexBuffers.Vector map = FlexBuffers.Vector.empty();
    FlexBuffers.TypedVector typedAry = FlexBuffers.TypedVector.empty();
    assertEquals(blob.size(), 0);
    assertEquals(map.size(), 0);
    assertEquals(ary.size(), 0);
    assertEquals(typedAry.size(), 0);
  }

  @Test
  public void testHashMapToMap() {
    int entriesCount = 12;

    HashMap<String, String> source = new HashMap<>();
    for (int i = 0; i < entriesCount; i++) {
      source.put("foo_param_" + i, "foo_value_" + i);
    }

    FlexBuffersBuilder builder = new FlexBuffersBuilder(1000);
    int mapStart = builder.startMap();
    for (Map.Entry<String, String> entry : source.entrySet()) {
      builder.putString(entry.getKey(), entry.getValue());
    }
    builder.endMap(null, mapStart);
    ByteBuffer bb = builder.finish();
    bb.rewind();

    FlexBuffers.Reference rootReference = FlexBuffers.getRoot(bb);

    assertTrue(rootReference.isMap());

    FlexBuffers.Map flexMap = rootReference.asMap();

    FlexBuffers.KeyVector keys = flexMap.keys();
    FlexBuffers.Vector values = flexMap.values();

    assertEquals(entriesCount, keys.size());
    assertEquals(entriesCount, values.size());

    HashMap<String, String> result = new HashMap<>();
    for (int i = 0; i < keys.size(); i++) {
      result.put(keys.get(i).toString(), values.get(i).asString());
    }

    assertEquals(source, result);
  }

  @Test
  public void testBuilderGrowth() {
    FlexBuffersBuilder builder = new FlexBuffersBuilder();
    String someString = "This is a small string";
    builder.putString(someString);
    ByteBuffer b = builder.finish();
    assertEquals(someString, FlexBuffers.getRoot(b).asString());

    FlexBuffersBuilder failBuilder = new FlexBuffersBuilder(ByteBuffer.allocate(1));
    failBuilder.putString(someString);
  }

  @Test
  public void testFlexBuffersUtf8Map() {
    FlexBuffersBuilder builder = new FlexBuffersBuilder(ByteBuffer.allocate(512),
      FlexBuffersBuilder.BUILDER_FLAG_SHARE_KEYS_AND_STRINGS);

    String key0 = "ðŸ˜¨ face1";
    String key1 = "ðŸ˜© face2";
    String key2 = "ðŸ˜¨ face3";
    String key3 = "trademark Â®";
    String key4 = "â‚¬ euro";
    String[] utf8keys = {"ðŸ˜¨ face1", "ðŸ˜© face2", "ðŸ˜¨ face3", "trademark Â®", "â‚¬ euro"};

    int map = builder.startMap();

    for (String utf8key : utf8keys) {
      builder.putString(utf8key, utf8key);  // Testing key and string reuse.
    }
    builder.endMap(null, map);
    builder.finish();

    FlexBuffers.Map m = FlexBuffers.getRoot(builder.getBuffer()).asMap();

    assertEquals(m.size(), 5);

    KeyVector kv = m.keys();
    for (int i = 0; i < utf8keys.length; i++) {
      assertEquals(kv.get(i).toString(), m.get(i).asString());
    }

    assertEquals(m.get(key0).asString(), utf8keys[0]);
    assertEquals(m.get(key1).asString(), utf8keys[1]);
    assertEquals(m.get(key2).asString(), utf8keys[2]);
    assertEquals(m.get(key3).asString(), utf8keys[3]);
    assertEquals(m.get(key4).asString(), utf8keys[4]);
  }

  @Test
  public void testFlexBuffersMapLookup() {
    FlexBuffersBuilder builder = new FlexBuffersBuilder(ByteBuffer.allocate(512),
      FlexBuffersBuilder.BUILDER_FLAG_SHARE_KEYS_AND_STRINGS);

    String key0 = "123";
    String key1 = "1234";
    String key2 = "12345";
    String[] keys = new String[]{key0, key1, key2};

    int map = builder.startMap();

    for (String key : keys) {
      builder.putString(key, key);  // Testing key and string reuse.
    }
    builder.endMap(null, map);
    builder.finish();

    FlexBuffers.Map m = FlexBuffers.getRoot(builder.getBuffer()).asMap();
    for (String key : keys) {
      assertEquals(m.get(key).asString(), key);
      assertEquals(m.get(key.getBytes(StandardCharsets.UTF_8)).asString(), key);
    }
  }

  @Test
  public void TestFlexBuffers() {
    testSingleElementByte();
    testSingleElementShort();
    testSingleElementInt();
    testSingleElementLong();
    testSingleElementFloat();
    testSingleElementDouble();
    testSingleElementSmallString();
    testSingleElementBigString();
    testSingleElementBlob();
    testSingleElementLongBlob();
    testSingleElementVector();
    testSingleFixedTypeVector();
    testSingleElementUShort();
    testSingleElementUInt();
    testSingleElementUByte();
    testSingleElementMap();
    testFlexBuffersTest();
    testHashMapToMap();
    testFlexBuferEmpty();
    testFlexBufferVectorStrings();
    testDeprecatedTypedVectorString();
    testBuilderGrowth();
    testFlexBuffersUtf8Map();
    testFlexBuffersMapLookup();
  }

  @Test
  void TestVectorOfBytes() {
    FlatBufferBuilder fbb = new FlatBufferBuilder(16);
    int str = fbb.createString("ByteMonster");
    byte[] data = new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    int offset = Monster.createInventoryVector(fbb, data);
    Monster.startMonster(fbb);
    Monster.addName(fbb, str);
    Monster.addInventory(fbb, offset);
    int monster1 = Monster.endMonster(fbb);
    Monster.finishMonsterBuffer(fbb, monster1);
    Monster monsterObject = Monster.getRootAsMonster(fbb.dataBuffer());

    assertEquals(monsterObject.inventoryLength(), data.length);
    assertEquals(monsterObject.inventory(4), data[4]);
    assertEquals(ByteBuffer.wrap(data), monsterObject.inventoryAsByteBuffer());

    fbb.clear();
    ByteBuffer bb = ByteBuffer.wrap(data);
    offset = fbb.createByteVector(bb);
    str = fbb.createString("ByteMonster");
    Monster.startMonster(fbb);
    Monster.addName(fbb, str);
    Monster.addInventory(fbb, offset);
    monster1 = Monster.endMonster(fbb);
    Monster.finishMonsterBuffer(fbb, monster1);
    Monster monsterObject2 = Monster.getRootAsMonster(fbb.dataBuffer());

    assertEquals(monsterObject2.inventoryLength(), data.length);
    for (int i = 0; i < data.length; i++) {
      assertEquals(monsterObject2.inventory(i), bb.get(i));
    }

    fbb.clear();
    offset = fbb.createByteVector(data, 3, 4);
    str = fbb.createString("ByteMonster");
    Monster.startMonster(fbb);
    Monster.addName(fbb, str);
    Monster.addInventory(fbb, offset);
    monster1 = Monster.endMonster(fbb);
    Monster.finishMonsterBuffer(fbb, monster1);
    Monster monsterObject3 = Monster.getRootAsMonster(fbb.dataBuffer());

    assertEquals(monsterObject3.inventoryLength(), 4);
    assertEquals(monsterObject3.inventory(0), data[3]);

    fbb.clear();
    bb = ByteBuffer.wrap(data);
    offset = Monster.createInventoryVector(fbb, bb);
    str = fbb.createString("ByteMonster");
    Monster.startMonster(fbb);
    Monster.addName(fbb, str);
    Monster.addInventory(fbb, offset);
    monster1 = Monster.endMonster(fbb);
    Monster.finishMonsterBuffer(fbb, monster1);
    Monster monsterObject4 = Monster.getRootAsMonster(fbb.dataBuffer());

    assertEquals(monsterObject4.inventoryLength(), data.length);
    assertEquals(monsterObject4.inventory(8), 8);

    fbb.clear();
    byte[] largeData = new byte[1024];
    offset = fbb.createByteVector(largeData);
    str = fbb.createString("ByteMonster");
    Monster.startMonster(fbb);
    Monster.addName(fbb, str);
    Monster.addInventory(fbb, offset);
    monster1 = Monster.endMonster(fbb);
    Monster.finishMonsterBuffer(fbb, monster1);
    Monster monsterObject5 = Monster.getRootAsMonster(fbb.dataBuffer());

    assertEquals(monsterObject5.inventoryLength(), largeData.length);
    assertEquals(monsterObject5.inventory(25), largeData[25]);

    fbb.clear();
    bb = ByteBuffer.wrap(largeData);
    bb.position(512);
    ByteBuffer bb2 = bb.slice();
    assertEquals(bb2.arrayOffset(), 512);
    offset = fbb.createByteVector(bb2);
    str = fbb.createString("ByteMonster");
    Monster.startMonster(fbb);
    Monster.addName(fbb, str);
    Monster.addInventory(fbb, offset);
    monster1 = Monster.endMonster(fbb);
    Monster.finishMonsterBuffer(fbb, monster1);
    Monster monsterObject6 = Monster.getRootAsMonster(fbb.dataBuffer());

    assertEquals(monsterObject6.inventoryLength(), 512);
    assertEquals(monsterObject6.inventory(0), largeData[512]);

    fbb.clear();
    bb = ByteBuffer.wrap(largeData);
    bb.limit(256);
    offset = fbb.createByteVector(bb);
    str = fbb.createString("ByteMonster");
    Monster.startMonster(fbb);
    Monster.addName(fbb, str);
    Monster.addInventory(fbb, offset);
    monster1 = Monster.endMonster(fbb);
    Monster.finishMonsterBuffer(fbb, monster1);
    Monster monsterObject7 = Monster.getRootAsMonster(fbb.dataBuffer());

    assertEquals(monsterObject7.inventoryLength(), 256);

    fbb.clear();
    bb = ByteBuffer.allocateDirect(2048);
    offset = fbb.createByteVector(bb);
    str = fbb.createString("ByteMonster");
    Monster.startMonster(fbb);
    Monster.addName(fbb, str);
    Monster.addInventory(fbb, offset);
    monster1 = Monster.endMonster(fbb);
    Monster.finishMonsterBuffer(fbb, monster1);
    Monster monsterObject8 = Monster.getRootAsMonster(fbb.dataBuffer());

    assertEquals(monsterObject8.inventoryLength(), 2048);
  }

  @Test
  void TestSharedStringPool() {
    FlatBufferBuilder fb = new FlatBufferBuilder(1);
    String testString = "My string";
    int offset = fb.createSharedString(testString);
    for (int i = 0; i < 10; i++) {
      assertEquals(offset, fb.createSharedString(testString));
    }
  }

  @Test
  void TestScalarOptional() {
    FlatBufferBuilder fbb = new FlatBufferBuilder(1);
    ScalarStuff.startScalarStuff(fbb);
    int pos = ScalarStuff.endScalarStuff(fbb);
    fbb.finish(pos);

    ScalarStuff scalarStuff = ScalarStuff.getRootAsScalarStuff(fbb.dataBuffer());
    assertEquals(scalarStuff.justI8(), (byte) 0);
    assertEquals(scalarStuff.maybeI8(), (byte) 0);
    assertEquals(scalarStuff.defaultI8(), (byte) 42);
    assertEquals(scalarStuff.justU8(), 0);
    assertEquals(scalarStuff.maybeU8(), 0);
    assertEquals(scalarStuff.defaultU8(), 42);
    assertEquals(scalarStuff.justI16(), (short) 0);
    assertEquals(scalarStuff.maybeI16(), (short) 0);
    assertEquals(scalarStuff.defaultI16(), (short) 42);
    assertEquals(scalarStuff.justU16(), 0);
    assertEquals(scalarStuff.maybeU16(), 0);
    assertEquals(scalarStuff.defaultU16(), 42);
    assertEquals(scalarStuff.justI32(), 0);
    assertEquals(scalarStuff.maybeI32(), 0);
    assertEquals(scalarStuff.defaultI32(), 42);
    assertEquals(scalarStuff.justU32(), 0L);
    assertEquals(scalarStuff.maybeU32(), 0L);
    assertEquals(scalarStuff.defaultU32(), 42L);
    assertEquals(scalarStuff.justI64(), 0L);
    assertEquals(scalarStuff.maybeI64(), 0L);
    assertEquals(scalarStuff.defaultI64(), 42L);
    assertEquals(scalarStuff.justU64(), 0L);
    assertEquals(scalarStuff.maybeU64(), 0L);
    assertEquals(scalarStuff.defaultU64(), 42L);
    assertEquals(scalarStuff.justF32(), 0.0f);
    assertEquals(scalarStuff.maybeF32(), 0f);
    assertEquals(scalarStuff.defaultF32(), 42.0f);
    assertEquals(scalarStuff.justF64(), 0.0);
    assertEquals(scalarStuff.maybeF64(), 0.0);
    assertEquals(scalarStuff.defaultF64(), 42.0);
    assertFalse(scalarStuff.justBool());
    assertFalse(scalarStuff.maybeBool());
    assertTrue(scalarStuff.defaultBool());
    assertEquals(scalarStuff.justEnum(), OptionalByte.None);
    assertEquals(scalarStuff.maybeEnum(), OptionalByte.None);
    assertEquals(scalarStuff.defaultEnum(), OptionalByte.One);

    assertFalse(scalarStuff.hasMaybeI8());
    assertFalse(scalarStuff.hasMaybeI16());
    assertFalse(scalarStuff.hasMaybeI32());
    assertFalse(scalarStuff.hasMaybeI64());
    assertFalse(scalarStuff.hasMaybeU8());
    assertFalse(scalarStuff.hasMaybeU16());
    assertFalse(scalarStuff.hasMaybeU32());
    assertFalse(scalarStuff.hasMaybeU64());
    assertFalse(scalarStuff.hasMaybeF32());
    assertFalse(scalarStuff.hasMaybeF64());
    assertFalse(scalarStuff.hasMaybeBool());
    assertFalse(scalarStuff.hasMaybeEnum());

    fbb.clear();

    ScalarStuff.startScalarStuff(fbb);
    ScalarStuff.addJustI8(fbb, (byte) 5);
    ScalarStuff.addMaybeI8(fbb, (byte) 5);
    ScalarStuff.addDefaultI8(fbb, (byte) 5);
    ScalarStuff.addJustU8(fbb, 6);
    ScalarStuff.addMaybeU8(fbb, 6);
    ScalarStuff.addDefaultU8(fbb, 6);
    ScalarStuff.addJustI16(fbb, (short) 7);
    ScalarStuff.addMaybeI16(fbb, (short) 7);
    ScalarStuff.addDefaultI16(fbb, (short) 7);
    ScalarStuff.addJustU16(fbb, 8);
    ScalarStuff.addMaybeU16(fbb, 8);
    ScalarStuff.addDefaultU16(fbb, 8);
    ScalarStuff.addJustI32(fbb, 9);
    ScalarStuff.addMaybeI32(fbb, 9);
    ScalarStuff.addDefaultI32(fbb, 9);
    ScalarStuff.addJustU32(fbb, 10);
    ScalarStuff.addMaybeU32(fbb, 10);
    ScalarStuff.addDefaultU32(fbb, 10);
    ScalarStuff.addJustI64(fbb, 11L);
    ScalarStuff.addMaybeI64(fbb, 11L);
    ScalarStuff.addDefaultI64(fbb, 11L);
    ScalarStuff.addJustU64(fbb, 12L);
    ScalarStuff.addMaybeU64(fbb, 12L);
    ScalarStuff.addDefaultU64(fbb, 12L);
    ScalarStuff.addJustF32(fbb, 13.0f);
    ScalarStuff.addMaybeF32(fbb, 13.0f);
    ScalarStuff.addDefaultF32(fbb, 13.0f);
    ScalarStuff.addJustF64(fbb, 14.0);
    ScalarStuff.addMaybeF64(fbb, 14.0);
    ScalarStuff.addDefaultF64(fbb, 14.0);
    ScalarStuff.addJustBool(fbb, true);
    ScalarStuff.addMaybeBool(fbb, true);
    ScalarStuff.addDefaultBool(fbb, true);
    ScalarStuff.addJustEnum(fbb, OptionalByte.Two);
    ScalarStuff.addMaybeEnum(fbb, OptionalByte.Two);
    ScalarStuff.addDefaultEnum(fbb, OptionalByte.Two);

    pos = ScalarStuff.endScalarStuff(fbb);

    fbb.finish(pos);

    scalarStuff = ScalarStuff.getRootAsScalarStuff(fbb.dataBuffer());

    assertEquals(scalarStuff.justI8(), (byte) 5);
    assertEquals(scalarStuff.maybeI8(), (byte) 5);
    assertEquals(scalarStuff.defaultI8(), (byte) 5);
    assertEquals(scalarStuff.justU8(), 6);
    assertEquals(scalarStuff.maybeU8(), 6);
    assertEquals(scalarStuff.defaultU8(), 6);
    assertEquals(scalarStuff.justI16(), (short) 7);
    assertEquals(scalarStuff.maybeI16(), (short) 7);
    assertEquals(scalarStuff.defaultI16(), (short) 7);
    assertEquals(scalarStuff.justU16(), 8);
    assertEquals(scalarStuff.maybeU16(), 8);
    assertEquals(scalarStuff.defaultU16(), 8);
    assertEquals(scalarStuff.justI32(), 9);
    assertEquals(scalarStuff.maybeI32(), 9);
    assertEquals(scalarStuff.defaultI32(), 9);
    assertEquals(scalarStuff.justU32(), 10L);
    assertEquals(scalarStuff.maybeU32(), 10L);
    assertEquals(scalarStuff.defaultU32(), 10L);
    assertEquals(scalarStuff.justI64(), 11L);
    assertEquals(scalarStuff.maybeI64(), 11L);
    assertEquals(scalarStuff.defaultI64(), 11L);
    assertEquals(scalarStuff.justU64(), 12L);
    assertEquals(scalarStuff.maybeU64(), 12L);
    assertEquals(scalarStuff.defaultU64(), 12L);
    assertEquals(scalarStuff.justF32(), 13.0f);
    assertEquals(scalarStuff.maybeF32(), 13.0f);
    assertEquals(scalarStuff.defaultF32(), 13.0f);
    assertEquals(scalarStuff.justF64(), 14.0);
    assertEquals(scalarStuff.maybeF64(), 14.0);
    assertEquals(scalarStuff.defaultF64(), 14.0);
    assertTrue(scalarStuff.justBool());
    assertTrue(scalarStuff.maybeBool());
    assertTrue(scalarStuff.defaultBool());
    assertEquals(scalarStuff.justEnum(), OptionalByte.Two);
    assertEquals(scalarStuff.maybeEnum(), OptionalByte.Two);
    assertEquals(scalarStuff.defaultEnum(), OptionalByte.Two);

    assertTrue(scalarStuff.hasMaybeI8());
    assertTrue(scalarStuff.hasMaybeI16());
    assertTrue(scalarStuff.hasMaybeI32());
    assertTrue(scalarStuff.hasMaybeI64());
    assertTrue(scalarStuff.hasMaybeU8());
    assertTrue(scalarStuff.hasMaybeU16());
    assertTrue(scalarStuff.hasMaybeU32());
    assertTrue(scalarStuff.hasMaybeU64());
    assertTrue(scalarStuff.hasMaybeF32());
    assertTrue(scalarStuff.hasMaybeF64());
    assertTrue(scalarStuff.hasMaybeBool());
    assertTrue(scalarStuff.hasMaybeEnum());
  }

  void TestObject(MonsterT monster) {
    assertEquals(monster.getHp(), (short) 80);
    assertEquals(monster.getMana(), (short) 150);  // default

    assertEquals(monster.getName(), "MyMonster");
    assertEquals(monster.getColor(), Color.Blue);
    // monster.friendly() // can't access, deprecated

    Vec3T pos = monster.getPos();
    assertEquals(pos.getX(), 1.0f);
    assertEquals(pos.getY(), 2.0f);
    assertEquals(pos.getZ(), 3.0f);
    assertEquals(pos.getTest1(), 3.0);
    // issue: int != byte
    assertEquals(pos.getTest2(), Color.Green);
    TestT t = pos.getTest3();
    assertEquals(t.getA(), (short) 5);
    assertEquals(t.getB(), (byte) 6);

    assertEquals(monster.getTest().getType(), Any.Monster);
    MonsterT monster2 = (MonsterT) monster.getTest().getValue();
    assertNotNull(monster2);
    assertEquals(monster2.getName(), "Fred");

    int[] inv = monster.getInventory();
    assertEquals(inv.length, 5);
    int[] expInv = {0, 1, 2, 3, 4};
    for (int i = 0; i < inv.length; i++) {
      assertEquals(expInv[i], inv[i]);
    }

    TestT[] test4 = monster.getTest4();
    TestT test_0 = test4[0];
    TestT test_1 = test4[1];
    assertEquals(test4.length, 2);
    assertEquals(test_0.getA(), (short) 10);
    assertEquals(test_0.getB(), (byte) 20);
    assertEquals(test_1.getA(), (short) 30);
    assertEquals(test_1.getB(), (byte) 40);

    String[] testarrayofstring = monster.getTestarrayofstring();
    assertEquals(testarrayofstring.length, 2);
    assertEquals(testarrayofstring[0], "test1");
    assertEquals(testarrayofstring[1], "test2");

    MonsterT[] testarrayoftables = monster.getTestarrayoftables();
    assertEquals(testarrayoftables.length, 0);

    MonsterT enemy = monster.getEnemy();
    assertNotNull(enemy);
    assertEquals("", "");
    assertEquals(enemy.getName(), "Fred");

    int[] testnestedflatbuffer = monster.getTestnestedflatbuffer();
    assertEquals(testnestedflatbuffer.length, 0);

    assertNull(monster.getTestempty());

    assertTrue(monster.getTestbool());

    boolean[] testarrayofbools = monster.getTestarrayofbools();
    assertEquals(testarrayofbools.length, 3);
    assertTrue(testarrayofbools[0]);
    assertFalse(testarrayofbools[1]);
    assertTrue(testarrayofbools[2]);

    assertEquals(monster.getTestf(), 3.14159f);
    assertEquals(monster.getTestf2(), 3.0f);
    assertEquals(monster.getTestf3(), 0.0f);
    assertEquals(monster.getTestf3(), 0.0f);

    AbilityT[] testarrayofsortedstruct = monster.getTestarrayofsortedstruct();
    assertEquals(testarrayofsortedstruct.length, 3);
    assertEquals(testarrayofsortedstruct[0].getId(), 0);
    assertEquals(testarrayofsortedstruct[1].getId(), 1);
    assertEquals(testarrayofsortedstruct[2].getId(), 5);
    assertEquals(testarrayofsortedstruct[0].getDistance(), 45);
    assertEquals(testarrayofsortedstruct[1].getDistance(), 21);
    assertEquals(testarrayofsortedstruct[2].getDistance(), 12);

    int[] flex = monster.getFlex();
    assertEquals(flex.length, 0);

    long[] vectorOfLongs = monster.getVectorOfLongs();
    assertEquals(vectorOfLongs.length, 5);
    long l = 1;
    for (long vectorOfLong : vectorOfLongs) {
      assertEquals(vectorOfLong, l);
      l *= 100;
    }

    double[] vectorOfDoubles = monster.getVectorOfDoubles();
    assertEquals(vectorOfDoubles.length, 3);
    assertEquals(vectorOfDoubles[0], -1.7976931348623157E308);
    assertEquals(vectorOfDoubles[1], 0.0);
    assertEquals(vectorOfDoubles[2], 1.7976931348623157E308);

    assertNull(monster.getParentNamespaceTest());
    ReferrableT[] vectorOfReferrables = monster.getVectorOfReferrables();
    assertEquals(vectorOfReferrables.length, 0);

    assertEquals(monster.getSignedEnum(), (byte) -1);
  }

  void TestPackUnpack(ByteBuffer bb) {
    Monster m = Monster.getRootAsMonster(bb);
    MonsterT mObject = m.unpack();
    TestObject(mObject);
    FlatBufferBuilder fbb = new FlatBufferBuilder();
    int monster = Monster.pack(fbb, mObject);
    Monster.finishMonsterBuffer(fbb, monster);
    TestBuffer(fbb.dataBuffer());

    byte[] bytes = mObject.serializeToBinary();
    MonsterT newMonsterT = MonsterT.deserializeFromBinary(bytes);
    TestObject(newMonsterT);
  }
}
