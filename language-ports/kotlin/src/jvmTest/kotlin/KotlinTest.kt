/*
 * Copyright 2014 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import MyGame.Example.Any_
import MyGame.Example.Color
import MyGame.Example.Monster
import MyGame.Example.Vec3
import NamespaceA.NamespaceB.TableInNestedNS
import NamespaceA.TableInFirstNS
import com.google.flatbuffers.ByteBufferUtil
import com.google.flatbuffers.Constants.SIZE_PREFIX_LENGTH
import com.google.flatbuffers.FlatBufferBuilder
import java.io.FileOutputStream
import java.io.RandomAccessFile
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.channels.FileChannel
import optional_scalars.OptionalByte
import optional_scalars.ScalarStuff
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertFalse
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test
import MyGame.Example.Test as FbTestClass

fun main() {
  // Now test it:
  with(KotlinTest()) {
    TestBuffer()

    TestNamespaceNesting()

    TestNestedFlatBuffer()

    TestCreateByteVector()

    TestCreateUninitializedVector()

    TestByteBufferFactory()

    TestSizedInputStream()

    TestVectorOfUnions()

    TestSharedStringPool()
    TestScalarOptional()
  }
  println("FlatBuffers test: completed successfully")
}


@kotlin.ExperimentalUnsignedTypes
class KotlinTest {

  @Test
  fun `test FlatBufferBuilder`() {
    // Second, let's create a FlatBuffer from scratch in Java, and test it also.
    // We use an initial size of 1 to exercise the reallocation algorithm,
    // normally a size larger than the typical FlatBuffer you generate would be
    // better for performance.
    val fbb = FlatBufferBuilder(1)

    TestBuilderBasics(fbb, true)
    TestBuilderBasics(fbb, false)

    TestExtendedBuffer(fbb.dataBuffer().asReadOnlyBuffer())
  }

  @Test
  fun TestEnums() {
    assertTrue(Color.name(Color.Red.toInt()) == "Red")
    assertTrue(Color.name(Color.Blue.toInt()) == "Blue")
    assertTrue(Any_.name(Any_.NONE.toInt()) == "NONE")
    assertTrue(Any_.name(Any_.Monster.toInt()) == "Monster")
  }

  @Test
  fun TestBuffer() {

    // First, let's test reading a FlatBuffer generated by C++ code:
    // This file was generated from monsterdata_test.json
    val data: ByteArray =
      ClassLoader.getSystemResource("monsterdata_test.mon").openStream().readAllBytes()
    val bb = ByteBuffer.wrap(data)

    assertTrue(Monster.MonsterBufferHasIdentifier(bb))

    val monster = Monster.getRootAsMonster(bb)

    assertTrue(monster.hp == 80.toShort())
    assertTrue(monster.mana == 150.toShort())  // default

    assertTrue(monster.name == "MyMonster")
    // monster.friendly() // can't access, deprecated

    val pos = monster.pos!!
    assertTrue(pos.x == 1.0f)
    assertTrue(pos.y == 2.0f)
    assertTrue(pos.z == 3.0f)
    assertTrue(pos.test1 == 3.0)
    // issue: int != byte
    assertTrue(pos.test2 == Color.Green)
    val t = pos.test3!!
    assertTrue(t.a == 5.toShort())
    assertTrue(t.b == 6.toByte())

    assertTrue(monster.testType == Any_.Monster)
    val monster2 = Monster()
    assertTrue(monster.test(monster2) != null)
    assertTrue(monster2.name == "Fred")

    assertTrue(monster.inventoryLength == 5)
    var invsum = 0u
    for (i in 0 until monster.inventoryLength)
      invsum += monster.inventory(i)
    assertTrue(invsum == 10u)

    // Alternative way of accessing a vector:
    val ibb = monster.inventoryAsByteBuffer
    invsum = 0u
    while (ibb.position() < ibb.limit())
      invsum += ibb.get().toUInt()
    assertTrue(invsum == 10u)


    val test_0 = monster.test4(0)!!
    val test_1 = monster.test4(1)!!
    assertTrue(monster.test4Length == 2)
    assertTrue(test_0.a + test_0.b + test_1.a + test_1.b == 100)

    assertTrue(monster.testarrayofstringLength == 2)
    assertTrue(monster.testarrayofstring(0) == "test1")
    assertTrue(monster.testarrayofstring(1) == "test2")

    assertTrue(monster.testbool)
  }

  // this method checks additional fields not present in the binary buffer read from file

  // these new tests are performed on top of the regular tests
  fun TestExtendedBuffer(bb: ByteBuffer) {
//    TestBuffer(bb)

    val monster = Monster.getRootAsMonster(bb)

    assertTrue(monster.testhashu32Fnv1 == (Integer.MAX_VALUE + 1L).toUInt())
  }

  @Test
  fun TestNamespaceNesting() {
    // reference / manipulate these to verify compilation
    val fbb = FlatBufferBuilder(1)

    TableInNestedNS.startTableInNestedNS(fbb)
    TableInNestedNS.addFoo(fbb, 1234)
    val nestedTableOff = TableInNestedNS.endTableInNestedNS(fbb)

    TableInFirstNS.startTableInFirstNS(fbb)
    TableInFirstNS.addFooTable(fbb, nestedTableOff)
  }

  @Test
  fun TestNestedFlatBuffer() {
    val nestedMonsterName = "NestedMonsterName"
    val nestedMonsterHp: Short = 600
    val nestedMonsterMana: Short = 1024

    var fbb1: FlatBufferBuilder? = FlatBufferBuilder(16)
    val str1 = fbb1!!.createString(nestedMonsterName)
    Monster.startMonster(fbb1)
    Monster.addName(fbb1, str1)
    Monster.addHp(fbb1, nestedMonsterHp)
    Monster.addMana(fbb1, nestedMonsterMana)
    val monster1 = Monster.endMonster(fbb1)
    Monster.finishMonsterBuffer(fbb1, monster1)
    val fbb1Bytes = fbb1.sizedByteArray()

    val fbb2 = FlatBufferBuilder(16)
    val str2 = fbb2.createString("My Monster")
    val nestedBuffer = Monster.createTestnestedflatbufferVector(fbb2, fbb1Bytes.asUByteArray())
    Monster.startMonster(fbb2)
    Monster.addName(fbb2, str2)
    Monster.addHp(fbb2, 50.toShort())
    Monster.addMana(fbb2, 32.toShort())
    Monster.addTestnestedflatbuffer(fbb2, nestedBuffer)
    val monster = Monster.endMonster(fbb2)
    Monster.finishMonsterBuffer(fbb2, monster)

    // Now test the data extracted from the nested buffer
    val mons = Monster.getRootAsMonster(fbb2.dataBuffer())
    val nestedMonster = mons.testnestedflatbufferAsMonster!!

    assertTrue(nestedMonsterMana == nestedMonster.mana)
    assertTrue(nestedMonsterHp == nestedMonster.hp)
    assertTrue(nestedMonsterName == nestedMonster.name)
  }

  @Test
  fun TestCreateByteVector() {
    val fbb = FlatBufferBuilder(16)
    val str = fbb.createString("MyMonster")
    val inventory = byteArrayOf(0, 1, 2, 3, 4)
    val vec = fbb.createByteVector(inventory)
    Monster.startMonster(fbb)
    Monster.addInventory(fbb, vec)
    Monster.addName(fbb, str)
    val monster1 = Monster.endMonster(fbb)
    Monster.finishMonsterBuffer(fbb, monster1)
    val monsterObject = Monster.getRootAsMonster(fbb.dataBuffer())

    assertTrue(monsterObject.inventory(1) == inventory[1].toUByte())
    assertTrue(monsterObject.inventoryLength == inventory.size)
    assertTrue(ByteBuffer.wrap(inventory) == monsterObject.inventoryAsByteBuffer)
  }

  @Test
  fun TestCreateUninitializedVector() {
    val fbb = FlatBufferBuilder(16)
    val str = fbb.createString("MyMonster")
    val inventory = byteArrayOf(0, 1, 2, 3, 4)
    val bb = fbb.createUnintializedVector(1, inventory.size, 1)
    for (i in inventory) {
      bb.put(i)
    }
    val vec = fbb.endVector()
    Monster.startMonster(fbb)
    Monster.addInventory(fbb, vec)
    Monster.addName(fbb, str)
    val monster1 = Monster.endMonster(fbb)
    Monster.finishMonsterBuffer(fbb, monster1)
    val monsterObject = Monster.getRootAsMonster(fbb.dataBuffer())

    assertTrue(monsterObject.inventory(1) == inventory[1].toUByte())
    assertTrue(monsterObject.inventoryLength == inventory.size)
    assertTrue(ByteBuffer.wrap(inventory) == monsterObject.inventoryAsByteBuffer)
  }

  @Test
  fun TestByteBufferFactory() {
    class MappedByteBufferFactory : FlatBufferBuilder.ByteBufferFactory() {
      override fun newByteBuffer(capacity: Int): ByteBuffer? {
        var bb: ByteBuffer?
        try {
          bb = RandomAccessFile("javatest.bin", "rw").channel.map(
            FileChannel.MapMode.READ_WRITE,
            0,
            capacity.toLong()
          ).order(ByteOrder.LITTLE_ENDIAN)
        } catch (e: Throwable) {
          println("FlatBuffers test: couldn't map ByteBuffer to a file")
          bb = null
        }

        return bb
      }
    }

    val fbb = FlatBufferBuilder(1, MappedByteBufferFactory())

    TestBuilderBasics(fbb, false)
  }

  @Test
  fun TestSizedInputStream() {
    // Test on default FlatBufferBuilder that uses HeapByteBuffer
    val fbb = FlatBufferBuilder(1)

    TestBuilderBasics(fbb, false)

    val `in` = fbb.sizedInputStream()
    val array = fbb.sizedByteArray()
    var count = 0
    var currentVal = 0

    while (currentVal != -1 && count < array.size) {
      try {
        currentVal = `in`.read()
      } catch (e: java.io.IOException) {
        println("FlatBuffers test: couldn't read from InputStream")
        return
      }

      assertTrue(currentVal.toByte() == array[count])
      count++
    }
    assertTrue(count == array.size)
  }

  fun TestBuilderBasics(fbb: FlatBufferBuilder, sizePrefix: Boolean) {
    val names =
      intArrayOf(fbb.createString("Frodo"), fbb.createString("Barney"), fbb.createString("Wilma"))
    val off = IntArray(3)
    Monster.startMonster(fbb)
    Monster.addName(fbb, names[0])
    off[0] = Monster.endMonster(fbb)
    Monster.startMonster(fbb)
    Monster.addName(fbb, names[1])
    off[1] = Monster.endMonster(fbb)
    Monster.startMonster(fbb)
    Monster.addName(fbb, names[2])
    off[2] = Monster.endMonster(fbb)
    val sortMons = fbb.createSortedVectorOfTables(Monster(), off)

    // We set up the same values as monsterdata.json:

    val str = fbb.createString("MyMonster")

    val inv = Monster.createInventoryVector(fbb, byteArrayOf(0, 1, 2, 3, 4).asUByteArray())

    val fred = fbb.createString("Fred")
    Monster.startMonster(fbb)
    Monster.addName(fbb, fred)
    val mon2 = Monster.endMonster(fbb)

    Monster.startTest4Vector(fbb, 2)
    FbTestClass.createTest(fbb, 10.toShort(), 20.toByte())
    FbTestClass.createTest(fbb, 30.toShort(), 40.toByte())
    val test4 = fbb.endVector()

    val testArrayOfString =
      Monster.createTestarrayofstringVector(
        fbb,
        intArrayOf(fbb.createString("test1"), fbb.createString("test2"))
      )

    Monster.startMonster(fbb)
    Monster.addPos(
      fbb, Vec3.createVec3(
        fbb, 1.0f, 2.0f, 3.0f, 3.0,
        Color.Green, 5.toShort(), 6.toByte()
      )
    )
    Monster.addHp(fbb, 80.toShort())
    Monster.addName(fbb, str)
    Monster.addInventory(fbb, inv)
    Monster.addTestType(fbb, Any_.Monster)
    Monster.addTest(fbb, mon2)
    Monster.addTest4(fbb, test4)
    Monster.addTestarrayofstring(fbb, testArrayOfString)
    Monster.addTestbool(fbb, true)
    Monster.addTesthashu32Fnv1(fbb, (Integer.MAX_VALUE + 1L).toUInt())
    Monster.addTestarrayoftables(fbb, sortMons)
    val mon = Monster.endMonster(fbb)

    if (sizePrefix) {
      Monster.finishSizePrefixedMonsterBuffer(fbb, mon)
    } else {
      Monster.finishMonsterBuffer(fbb, mon)
    }

    // Write the result to a file for debugging purposes:
    // Note that the binaries are not necessarily identical, since the JSON
    // parser may serialize in a slightly different order than the above
    // Java code. They are functionally equivalent though.

    try {
      val filename = "monsterdata_java_wire" + (if (sizePrefix) "_sp" else "") + ".mon"
      val fc = FileOutputStream(filename).channel
      fc.write(fbb.dataBuffer().duplicate())
      fc.close()
    } catch (e: java.io.IOException) {
      println("FlatBuffers test: couldn't write file")
      return
    }

    // Test it:
    var dataBuffer = fbb.dataBuffer()
    if (sizePrefix) {
      assertTrue(
        ByteBufferUtil.getSizePrefix(dataBuffer) + SIZE_PREFIX_LENGTH ==
          dataBuffer.remaining()
      )
      dataBuffer = ByteBufferUtil.removeSizePrefix(dataBuffer)
    }
    TestExtendedBuffer(dataBuffer)

    // Make sure it also works with read only ByteBuffers. This is slower,
    // since creating strings incurs an additional copy
    // (see Table.__string).
    TestExtendedBuffer(dataBuffer.asReadOnlyBuffer())

    TestEnums()

    //Attempt to mutate Monster fields and check whether the buffer has been mutated properly
    // revert to original values after testing
    val monster = Monster.getRootAsMonster(dataBuffer)

    // mana is optional and does not exist in the buffer so the mutation should fail
    // the mana field should retain its default value
    assertTrue(!monster.mutateMana(10.toShort()))
    assertTrue(monster.mana == 150.toShort())

    // Accessing a vector of sorted by the key tables
    assertTrue(monster.testarrayoftables(0)!!.name == "Barney")
    assertTrue(monster.testarrayoftables(1)!!.name == "Frodo")
    assertTrue(monster.testarrayoftables(2)!!.name == "Wilma")

    // Example of searching for a table by the key
    assertTrue(monster.testarrayoftablesByKey("Frodo")!!.name == "Frodo")
    assertTrue(monster.testarrayoftablesByKey("Barney")!!.name == "Barney")
    assertTrue(monster.testarrayoftablesByKey("Wilma")!!.name == "Wilma")

    // testType is an existing field and mutating it should succeed
    assertTrue(monster.testType == Any_.Monster)
    assertTrue(monster.mutateTestType(Any_.NONE))
    assertTrue(monster.testType == Any_.NONE)
    assertTrue(monster.mutateTestType(Any_.Monster))
    assertTrue(monster.testType == Any_.Monster)

    //mutate the inventory vector
    assertTrue(monster.mutateInventory(0, 1u))
    assertTrue(monster.mutateInventory(1, 2u))
    assertTrue(monster.mutateInventory(2, 3u))
    assertTrue(monster.mutateInventory(3, 4u))
    assertTrue(monster.mutateInventory(4, 5u))

    for (i in 0 until monster.inventoryLength) {
      assertTrue(monster.inventory(i) == (i.toUByte() + 1u).toUByte())
    }

    //reverse mutation
    assertTrue(monster.mutateInventory(0, 0u))
    assertTrue(monster.mutateInventory(1, 1u))
    assertTrue(monster.mutateInventory(2, 2u))
    assertTrue(monster.mutateInventory(3, 3u))
    assertTrue(monster.mutateInventory(4, 4u))

    // get a struct field and edit one of its fields
    val pos = monster.pos!!
    assertTrue(pos.x == 1.0f)
    pos.mutateX(55.0f)
    assertTrue(pos.x == 55.0f)
    pos.mutateX(1.0f)
    assertTrue(pos.x == 1.0f)
  }

  @Test
  fun TestVectorOfUnions() {
    val fbb = FlatBufferBuilder()

    val swordAttackDamage = 1

    val characterVector = intArrayOf(Attacker.createAttacker(fbb, swordAttackDamage))

    val characterTypeVector = ubyteArrayOf(Character_.MuLan)

    Movie.finishMovieBuffer(
      fbb,
      Movie.createMovie(
        fbb,
        0u,
        0,
        Movie.createCharactersTypeVector(fbb, characterTypeVector),
        Movie.createCharactersVector(fbb, characterVector)
      )
    )

    val movie = Movie.getRootAsMovie(fbb.dataBuffer())

    assertTrue(movie.charactersTypeLength == characterTypeVector.size)
    assertTrue(movie.charactersLength == characterVector.size)

    assertTrue(movie.charactersType(0) == characterTypeVector[0])

    assertTrue((movie.characters(Attacker(), 0) as Attacker).swordAttackDamage == swordAttackDamage)
  }

  @Test
  fun TestSharedStringPool() {
    val fb = FlatBufferBuilder(1)
    val testString = "My string"
    val offset = fb.createSharedString(testString)
    for (i in 0..10) {
      assertTrue(offset == fb.createSharedString(testString))
    }
  }

  @Test
  fun TestScalarOptional() {
    val fbb = FlatBufferBuilder(1)
    ScalarStuff.startScalarStuff(fbb)
    var pos = ScalarStuff.endScalarStuff(fbb)
    fbb.finish(pos)

    var scalarStuff = ScalarStuff.getRootAsScalarStuff(fbb.dataBuffer())

    assertEquals(0.toByte(), scalarStuff.justI8)
    assertEquals(null, scalarStuff.maybeI8)
    assertEquals(42.toByte(), scalarStuff.defaultI8)
    assertEquals(0.toUByte(), scalarStuff.justU8)
    assertEquals(null, scalarStuff.maybeU8)
    assertEquals(42.toUByte(), scalarStuff.defaultU8)
    assertEquals(0.toShort(), scalarStuff.justI16)
    assertEquals(null, scalarStuff.maybeI16)
    assertEquals(42.toShort(), scalarStuff.defaultI16)
    assertEquals(0.toUShort(), scalarStuff.justU16)
    assertEquals(null, scalarStuff.maybeU16)
    assertEquals(42.toUShort(), scalarStuff.defaultU16)
    assertEquals(0, scalarStuff.justI32)
    assertEquals(null, scalarStuff.maybeI32)
    assertEquals(42, scalarStuff.defaultI32)
    assertEquals(0.toUInt(), scalarStuff.justU32)
    assertEquals(null, scalarStuff.maybeU32)
    assertEquals(42U, scalarStuff.defaultU32)
    assertEquals(0L, scalarStuff.justI64)
    assertEquals(null, scalarStuff.maybeI64)
    assertEquals(42L, scalarStuff.defaultI64)
    assertEquals(0UL, scalarStuff.justU64)
    assertEquals(null, scalarStuff.maybeU64)
    assertEquals(42UL, scalarStuff.defaultU64)
    assertEquals(0.0f, scalarStuff.justF32)
    assertEquals(null, scalarStuff.maybeF32)
    assertEquals(42.0f, scalarStuff.defaultF32)
    assertEquals(0.0, scalarStuff.justF64)
    assertEquals(null, scalarStuff.maybeF64)
    assertEquals(42.0, scalarStuff.defaultF64)
    assertFalse(scalarStuff.justBool)
    assertTrue(scalarStuff.maybeBool == null)
    assertTrue(scalarStuff.defaultBool)
    assertTrue(scalarStuff.justEnum == OptionalByte.None)
    assertTrue(scalarStuff.maybeEnum == null)
    assertTrue(scalarStuff.defaultEnum == OptionalByte.One)

    fbb.clear()

    ScalarStuff.startScalarStuff(fbb)
    ScalarStuff.addJustI8(fbb, 5.toByte())
    ScalarStuff.addMaybeI8(fbb, 5.toByte())
    ScalarStuff.addDefaultI8(fbb, 5.toByte())
    ScalarStuff.addJustU8(fbb, 6.toUByte())
    ScalarStuff.addMaybeU8(fbb, 6.toUByte())
    ScalarStuff.addDefaultU8(fbb, 6.toUByte())
    ScalarStuff.addJustI16(fbb, 7.toShort())
    ScalarStuff.addMaybeI16(fbb, 7.toShort())
    ScalarStuff.addDefaultI16(fbb, 7.toShort())
    ScalarStuff.addJustU16(fbb, 8.toUShort())
    ScalarStuff.addMaybeU16(fbb, 8.toUShort())
    ScalarStuff.addDefaultU16(fbb, 8.toUShort())
    ScalarStuff.addJustI32(fbb, 9)
    ScalarStuff.addMaybeI32(fbb, 9)
    ScalarStuff.addDefaultI32(fbb, 9)
    ScalarStuff.addJustU32(fbb, 10.toUInt())
    ScalarStuff.addMaybeU32(fbb, 10.toUInt())
    ScalarStuff.addDefaultU32(fbb, 10.toUInt())
    ScalarStuff.addJustI64(fbb, 11L)
    ScalarStuff.addMaybeI64(fbb, 11L)
    ScalarStuff.addDefaultI64(fbb, 11L)
    ScalarStuff.addJustU64(fbb, 12UL)
    ScalarStuff.addMaybeU64(fbb, 12UL)
    ScalarStuff.addDefaultU64(fbb, 12UL)
    ScalarStuff.addJustF32(fbb, 13.0f)
    ScalarStuff.addMaybeF32(fbb, 13.0f)
    ScalarStuff.addDefaultF32(fbb, 13.0f)
    ScalarStuff.addJustF64(fbb, 14.0)
    ScalarStuff.addMaybeF64(fbb, 14.0)
    ScalarStuff.addDefaultF64(fbb, 14.0)
    ScalarStuff.addJustBool(fbb, true)
    ScalarStuff.addMaybeBool(fbb, true)
    ScalarStuff.addDefaultBool(fbb, true)
    ScalarStuff.addJustEnum(fbb, OptionalByte.Two)
    ScalarStuff.addMaybeEnum(fbb, OptionalByte.Two)
    ScalarStuff.addDefaultEnum(fbb, OptionalByte.Two)

    pos = ScalarStuff.endScalarStuff(fbb)

    fbb.finish(pos)

    scalarStuff = ScalarStuff.getRootAsScalarStuff(fbb.dataBuffer())

    assertTrue(scalarStuff.justI8 == 5.toByte())
    assertTrue(scalarStuff.maybeI8 == 5.toByte())
    assertTrue(scalarStuff.defaultI8 == 5.toByte())
    assertTrue(scalarStuff.justU8 == 6.toUByte())
    assertTrue(scalarStuff.maybeU8 == 6.toUByte())
    assertTrue(scalarStuff.defaultU8 == 6.toUByte())
    assertTrue(scalarStuff.justI16 == 7.toShort())
    assertTrue(scalarStuff.maybeI16 == 7.toShort())
    assertTrue(scalarStuff.defaultI16 == 7.toShort())
    assertTrue(scalarStuff.justU16 == 8.toUShort())
    assertTrue(scalarStuff.maybeU16 == 8.toUShort())
    assertTrue(scalarStuff.defaultU16 == 8.toUShort())
    assertTrue(scalarStuff.justI32 == 9)
    assertTrue(scalarStuff.maybeI32 == 9)
    assertTrue(scalarStuff.defaultI32 == 9)
    assertTrue(scalarStuff.justU32 == 10u)
    assertTrue(scalarStuff.maybeU32 == 10u)
    assertTrue(scalarStuff.defaultU32 == 10u)
    assertTrue(scalarStuff.justI64 == 11L)
    assertTrue(scalarStuff.maybeI64 == 11L)
    assertTrue(scalarStuff.defaultI64 == 11L)
    assertTrue(scalarStuff.justU64 == 12UL)
    assertTrue(scalarStuff.maybeU64 == 12UL)
    assertTrue(scalarStuff.defaultU64 == 12UL)
    assertTrue(scalarStuff.justF32 == 13.0f)
    assertTrue(scalarStuff.maybeF32 == 13.0f)
    assertTrue(scalarStuff.defaultF32 == 13.0f)
    assertTrue(scalarStuff.justF64 == 14.0)
    assertTrue(scalarStuff.maybeF64 == 14.0)
    assertTrue(scalarStuff.defaultF64 == 14.0)
    assertTrue(scalarStuff.justBool)
    assertTrue(scalarStuff.maybeBool == true)
    assertTrue(scalarStuff.defaultBool)
    assertTrue(scalarStuff.justEnum == OptionalByte.Two)
    assertTrue(scalarStuff.maybeEnum == OptionalByte.Two)
    assertTrue(scalarStuff.defaultEnum == OptionalByte.Two)
  }
}
