<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FlexBuffers.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">flatbuffers</a> &gt; <a href="index.source.html" class="el_package">com.google.flatbuffers</a> &gt; <span class="el_source">FlexBuffers.java</span></div><h1>FlexBuffers.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2014 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.flatbuffers;


import static com.google.flatbuffers.FlexBuffers.Unsigned.byteToUnsignedInt;
import static com.google.flatbuffers.FlexBuffers.Unsigned.intToUnsignedLong;
import static com.google.flatbuffers.FlexBuffers.Unsigned.shortToUnsignedInt;

import java.nio.ByteBuffer;

/// @file
/// @addtogroup flatbuffers_java_api
/// @{

/**
 * This class can be used to parse FlexBuffer messages.
 * &lt;p&gt;
 * For generating FlexBuffer messages, use {@link FlexBuffersBuilder}.
 * &lt;p&gt;
 * Example of usage:
 * &lt;pre&gt;
 * ReadBuf bb = ... // load message from file or network
 * FlexBuffers.Reference r = FlexBuffers.getRoot(bb); // Reads the root element
 * FlexBuffers.Map map = r.asMap(); // We assumed root object is a map
 * System.out.println(map.get(&quot;name&quot;).asString()); // prints element with key &quot;name&quot;
 * &lt;/pre&gt;
 */
<span class="pc bpc" id="L43" title="1 of 2 branches missed.">public class FlexBuffers {</span>

    // These are used as the upper 6 bits of a type field to indicate the actual
    // type.
    /** Represent a null type */
    public static final int FBT_NULL = 0;
    /** Represent a signed integer type */
    public static final int FBT_INT = 1;
    /** Represent a unsigned type */
    public static final int FBT_UINT = 2;
    /** Represent a float type */
    public static final int FBT_FLOAT = 3; // Types above stored inline, types below store an offset.
    /** Represent a key to a map type */
    public static final int FBT_KEY = 4;
    /** Represent a string type */
    public static final int FBT_STRING = 5;
    /** Represent a indirect signed integer type */
    public static final int FBT_INDIRECT_INT = 6;
    /** Represent a indirect unsigned integer type */
    public static final int FBT_INDIRECT_UINT = 7;
    /** Represent a indirect float type */
    public static final int FBT_INDIRECT_FLOAT = 8;
    /** Represent a map type */
    public static final int FBT_MAP = 9;
    /** Represent a vector type */
    public static final int FBT_VECTOR = 10; // Untyped.
    /** Represent a vector of signed integers type */
    public static final int FBT_VECTOR_INT = 11;  // Typed any size  = stores no type table).
    /** Represent a vector of unsigned integers type */
    public static final int FBT_VECTOR_UINT = 12;
    /** Represent a vector of floats type */
    public static final int FBT_VECTOR_FLOAT = 13;
    /** Represent a vector of keys type */
    public static final int FBT_VECTOR_KEY = 14;
    /**
     * Represent a vector of strings type
     *
     * @deprecated use FBT_VECTOR or FBT_VECTOR_KEY instead. More info: https://github.com/google/flatbuffers/issues/5627.
     */
    @Deprecated
    public static final int FBT_VECTOR_STRING_DEPRECATED = 15;

    /// @cond FLATBUFFERS_INTERNAL
    public static final int FBT_VECTOR_INT2 = 16;  // Typed tuple  = no type table; no size field).
    public static final int FBT_VECTOR_UINT2 = 17;
    public static final int FBT_VECTOR_FLOAT2 = 18;
    public static final int FBT_VECTOR_INT3 = 19;  // Typed triple  = no type table; no size field).
    public static final int FBT_VECTOR_UINT3 = 20;
    public static final int FBT_VECTOR_FLOAT3 = 21;
    public static final int FBT_VECTOR_INT4 = 22;  // Typed quad  = no type table; no size field).
    public static final int FBT_VECTOR_UINT4 = 23;
    public static final int FBT_VECTOR_FLOAT4 = 24;
    /// @endcond FLATBUFFERS_INTERNAL

    /** Represent a blob type */
    public static final int FBT_BLOB = 25;
    /** Represent a boolean type */
    public static final int FBT_BOOL = 26;
    /** Represent a vector of booleans type */
    public static final int FBT_VECTOR_BOOL = 36;  // To Allow the same type of conversion of type to vector type

<span class="fc" id="L104">    private static final ReadBuf EMPTY_BB = new ArrayReadWriteBuf(new byte[] {0}, 1);</span>

    /**
     * Checks where a type is a typed vector
     *
     * @param type type to be checked
     * @return true if typed vector
     */
    static boolean isTypedVector(int type) {
<span class="fc bfc" id="L113" title="All 6 branches covered.">        return (type &gt;= FBT_VECTOR_INT &amp;&amp; type &lt;= FBT_VECTOR_STRING_DEPRECATED) || type == FBT_VECTOR_BOOL;</span>
    }

    /**
     * Check whether you can access type directly (no indirection) or not.
     *
     * @param type type to be checked
     * @return true if inline type
     */
    static boolean isTypeInline(int type) {
<span class="fc bfc" id="L123" title="All 4 branches covered.">        return type &lt;= FBT_FLOAT || type == FBT_BOOL;</span>
    }

    static int toTypedVectorElementType(int original_type) {
<span class="fc" id="L127">        return original_type - FBT_VECTOR_INT + FBT_INT;</span>
    }

    /**
     * Return a vector type our of a original element type
     *
     * @param type        element type
     * @param fixedLength size of element
     * @return typed vector type
     */
    static int toTypedVector(int type, int fixedLength) {
<span class="pc bpc" id="L138" title="2 of 4 branches missed.">        assert (isTypedVectorElementType(type));</span>
<span class="pc bpc" id="L139" title="4 of 5 branches missed.">        switch (fixedLength) {</span>
<span class="fc" id="L140">            case 0: return type - FBT_INT + FBT_VECTOR_INT;</span>
<span class="nc" id="L141">            case 2: return type - FBT_INT + FBT_VECTOR_INT2;</span>
<span class="nc" id="L142">            case 3: return type - FBT_INT + FBT_VECTOR_INT3;</span>
<span class="nc" id="L143">            case 4: return type - FBT_INT + FBT_VECTOR_INT4;</span>
            default:
<span class="nc bnc" id="L145" title="All 2 branches missed.">                assert (false);</span>
<span class="nc" id="L146">                return FBT_NULL;</span>
        }
    }

    static boolean isTypedVectorElementType(int type) {
<span class="pc bpc" id="L151" title="1 of 6 branches missed.">        return (type &gt;= FBT_INT &amp;&amp; type &lt;= FBT_KEY) || type == FBT_BOOL;</span>
    }

    // return position of the element that the offset is pointing to
    private static int indirect(ReadBuf bb, int offset, int byteWidth) {
        // we assume all offset fits on a int, since ReadBuf operates with that assumption
<span class="fc" id="L157">        return (int) (offset - readUInt(bb, offset, byteWidth));</span>
    }

    // read unsigned int with size byteWidth and return as a 64-bit integer
    private static long readUInt(ReadBuf buff, int end, int byteWidth) {
<span class="pc bpc" id="L162" title="1 of 5 branches missed.">        switch (byteWidth) {</span>
<span class="fc" id="L163">            case 1: return byteToUnsignedInt(buff.get(end));</span>
<span class="fc" id="L164">            case 2: return shortToUnsignedInt(buff.getShort(end));</span>
<span class="fc" id="L165">            case 4: return intToUnsignedLong(buff.getInt(end));</span>
<span class="fc" id="L166">            case 8: return buff.getLong(end); // We are passing signed long here. Losing information (user should know)</span>
<span class="nc" id="L167">            default: return -1; // we should never reach here</span>
        }
    }

    // read signed int of size byteWidth and return as 32-bit int
    private static int readInt(ReadBuf buff, int end, int byteWidth) {
<span class="fc" id="L173">        return (int) readLong(buff, end, byteWidth);</span>
    }

    // read signed int of size byteWidth and return as 64-bit int
    private static long readLong(ReadBuf buff, int end, int byteWidth) {
<span class="pc bpc" id="L178" title="1 of 5 branches missed.">        switch (byteWidth) {</span>
<span class="fc" id="L179">            case 1: return buff.get(end);</span>
<span class="fc" id="L180">            case 2: return buff.getShort(end);</span>
<span class="fc" id="L181">            case 4: return buff.getInt(end);</span>
<span class="fc" id="L182">            case 8: return buff.getLong(end);</span>
<span class="nc" id="L183">            default: return -1; // we should never reach here</span>
        }
    }

    private static double readDouble(ReadBuf buff, int end, int byteWidth) {
<span class="pc bpc" id="L188" title="1 of 3 branches missed.">        switch (byteWidth) {</span>
<span class="fc" id="L189">            case 4: return buff.getFloat(end);</span>
<span class="fc" id="L190">            case 8: return buff.getDouble(end);</span>
<span class="nc" id="L191">            default: return -1; // we should never reach here</span>
        }
    }

    /**
     * Reads a FlexBuffer message in ReadBuf and returns {@link Reference} to
     * the root element.
     * @param buffer ReadBuf containing FlexBuffer message
     * @return {@link Reference} to the root object
     */
    @Deprecated
    public static Reference getRoot(ByteBuffer buffer) {
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">        return getRoot( buffer.hasArray() ? new ArrayReadWriteBuf(buffer.array(), buffer.limit()) : new ByteBufferReadWriteBuf(buffer));</span>
    }

        /**
     * Reads a FlexBuffer message in ReadBuf and returns {@link Reference} to
     * the root element.
     * @param buffer ReadBuf containing FlexBuffer message
     * @return {@link Reference} to the root object
     */
    public static Reference getRoot(ReadBuf buffer) {
        // See Finish() below for the serialization counterpart of this.
        // The root ends at the end of the buffer, so we parse backwards from there.
<span class="fc" id="L215">        int end = buffer.limit();</span>
<span class="fc" id="L216">        int byteWidth = buffer.get(--end);</span>
<span class="fc" id="L217">        int packetType = byteToUnsignedInt(buffer.get(--end));</span>
<span class="fc" id="L218">        end -= byteWidth;  // The root data item.</span>
<span class="fc" id="L219">        return new Reference(buffer, end, byteWidth, packetType);</span>
    }

    /**
     * Represents an generic element in the buffer.
     */
    public static class Reference {

<span class="fc" id="L227">        private static final Reference NULL_REFERENCE = new Reference(EMPTY_BB, 0, 1, 0);</span>
        private ReadBuf bb;
        private int end;
        private int parentWidth;
        private int byteWidth;
        private int type;

        Reference(ReadBuf bb, int end, int parentWidth, int packedType) {
<span class="fc" id="L235">            this(bb, end, parentWidth, (1 &lt;&lt; (packedType &amp; 3)), packedType &gt;&gt; 2);</span>
<span class="fc" id="L236">        }</span>

<span class="fc" id="L238">        Reference(ReadBuf bb, int end, int parentWidth, int byteWidth, int type) {</span>
<span class="fc" id="L239">            this.bb = bb;</span>
<span class="fc" id="L240">            this.end = end;</span>
<span class="fc" id="L241">            this.parentWidth = parentWidth;</span>
<span class="fc" id="L242">            this.byteWidth = byteWidth;</span>
<span class="fc" id="L243">            this.type = type;</span>
<span class="fc" id="L244">        }</span>

        /**
         * Return element type
         * @return element type as integer
         */
        public int getType() {
<span class="fc" id="L251">            return type;</span>
        }

        /**
         * Checks whether the element is null type
         * @return true if null type
         */
        public boolean isNull() {
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">            return type == FBT_NULL;</span>
        }

        /**
         * Checks whether the element is boolean type
         * @return true if boolean type
         */
        public boolean isBoolean() {
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">            return type == FBT_BOOL;</span>
        }

        /**
         * Checks whether the element type is numeric (signed/unsigned integers and floats)
         * @return true if numeric type
         */
        public boolean isNumeric() {
<span class="nc bnc" id="L275" title="All 4 branches missed.">            return isIntOrUInt() || isFloat();</span>
        }

        /**
         * Checks whether the element type is signed or unsigned integers
         * @return true if an integer type
         */
        public boolean isIntOrUInt() {
<span class="nc bnc" id="L283" title="All 4 branches missed.">            return isInt() || isUInt();</span>
        }

        /**
         * Checks whether the element type is float
         * @return true if a float type
         */
        public boolean isFloat() {
<span class="nc bnc" id="L291" title="All 4 branches missed.">            return type == FBT_FLOAT || type == FBT_INDIRECT_FLOAT;</span>
        }

        /**
         * Checks whether the element type is signed integer
         * @return true if a signed integer type
         */
        public boolean isInt() {
<span class="nc bnc" id="L299" title="All 4 branches missed.">            return type == FBT_INT || type == FBT_INDIRECT_INT;</span>
        }

        /**
         * Checks whether the element type is signed integer
         * @return true if a signed integer type
         */
        public boolean isUInt() {
<span class="nc bnc" id="L307" title="All 4 branches missed.">            return type == FBT_UINT || type == FBT_INDIRECT_UINT;</span>
        }

        /**
         * Checks whether the element type is string
         * @return true if a string type
         */
        public boolean isString() {
<span class="fc bfc" id="L315" title="All 2 branches covered.">            return type == FBT_STRING;</span>
        }

        /**
         * Checks whether the element type is key
         * @return true if a key type
         */
        public boolean isKey() {
<span class="fc bfc" id="L323" title="All 2 branches covered.">            return type == FBT_KEY;</span>
        }

        /**
         * Checks whether the element type is vector
         * @return true if a vector type
         */
        public boolean isVector() {
<span class="pc bpc" id="L331" title="1 of 4 branches missed.">            return type == FBT_VECTOR || type == FBT_MAP;</span>
        }

        /**
         * Checks whether the element type is typed vector
         * @return true if a typed vector type
         */
        public boolean isTypedVector() {
<span class="fc" id="L339">            return FlexBuffers.isTypedVector(type);</span>
        }

        /**
         * Checks whether the element type is a map
         * @return true if a map type
         */
        public boolean isMap() {
<span class="fc bfc" id="L347" title="All 2 branches covered.">            return type == FBT_MAP;</span>
        }

        /**
         * Checks whether the element type is a blob
         * @return true if a blob type
         */
        public boolean isBlob() {
<span class="fc bfc" id="L355" title="All 2 branches covered.">            return type == FBT_BLOB;</span>
        }

        /**
         * Returns element as 32-bit integer.
         * &lt;p&gt; For vector element, it will return size of the vector&lt;/p&gt;
         * &lt;p&gt; For String element, it will type to be parsed as integer&lt;/p&gt;
         * &lt;p&gt; Unsigned elements will become negative&lt;/p&gt;
         * &lt;p&gt; Float elements will be casted to integer &lt;/p&gt;
         * @return 32-bit integer or 0 if fail to convert element to integer.
         */
        public int asInt() {
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">            if (type == FBT_INT) {</span>
                // A fast path for the common case.
<span class="fc" id="L369">                return readInt(bb, end, parentWidth);</span>
            } else
<span class="nc bnc" id="L371" title="All 10 branches missed.">                switch (type) {</span>
<span class="nc" id="L372">                    case FBT_INDIRECT_INT: return readInt(bb, indirect(bb, end, parentWidth), byteWidth);</span>
<span class="nc" id="L373">                    case FBT_UINT: return (int) readUInt(bb, end, parentWidth);</span>
<span class="nc" id="L374">                    case FBT_INDIRECT_UINT: return (int) readUInt(bb, indirect(bb, end, parentWidth), parentWidth);</span>
<span class="nc" id="L375">                    case FBT_FLOAT: return (int) readDouble(bb, end, parentWidth);</span>
<span class="nc" id="L376">                    case FBT_INDIRECT_FLOAT: return (int) readDouble(bb, indirect(bb, end, parentWidth), byteWidth);</span>
<span class="nc" id="L377">                    case FBT_NULL: return 0;</span>
<span class="nc" id="L378">                    case FBT_STRING: return Integer.parseInt(asString());</span>
<span class="nc" id="L379">                    case FBT_VECTOR: return asVector().size();</span>
<span class="nc" id="L380">                    case FBT_BOOL: return readInt(bb, end, parentWidth);</span>
                    default:
                        // Convert other things to int.
<span class="nc" id="L383">                        return 0;</span>
                }
        }

        /**
         * Returns element as unsigned 64-bit integer.
         * &lt;p&gt; For vector element, it will return size of the vector&lt;/p&gt;
         * &lt;p&gt; For String element, it will type to be parsed as integer&lt;/p&gt;
         * &lt;p&gt; Negative signed elements will become unsigned counterpart&lt;/p&gt;
         * &lt;p&gt; Float elements will be casted to integer &lt;/p&gt;
         * @return 64-bit integer or 0 if fail to convert element to integer.
         */
        public long asUInt() {
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">            if (type == FBT_UINT) {</span>
                // A fast path for the common case.
<span class="fc" id="L398">                return readUInt(bb, end, parentWidth);</span>
            } else
<span class="nc bnc" id="L400" title="All 10 branches missed.">                switch (type) {</span>
<span class="nc" id="L401">                    case FBT_INDIRECT_UINT: return readUInt(bb, indirect(bb, end, parentWidth), byteWidth);</span>
<span class="nc" id="L402">                    case FBT_INT: return readLong(bb, end, parentWidth);</span>
<span class="nc" id="L403">                    case FBT_INDIRECT_INT: return readLong(bb, indirect(bb, end, parentWidth), byteWidth);</span>
<span class="nc" id="L404">                    case FBT_FLOAT: return (long) readDouble(bb, end, parentWidth);</span>
<span class="nc" id="L405">                    case FBT_INDIRECT_FLOAT: return (long) readDouble(bb,  indirect(bb, end, parentWidth), parentWidth);</span>
<span class="nc" id="L406">                    case FBT_NULL: return 0;</span>
<span class="nc" id="L407">                    case FBT_STRING: return Long.parseLong(asString());</span>
<span class="nc" id="L408">                    case FBT_VECTOR: return asVector().size();</span>
<span class="nc" id="L409">                    case FBT_BOOL: return readInt(bb, end, parentWidth);</span>
                    default:
                        // Convert other things to uint.
<span class="nc" id="L412">                        return 0;</span>
                }
        }

        /**
         * Returns element as 64-bit integer.
         * &lt;p&gt; For vector element, it will return size of the vector&lt;/p&gt;
         * &lt;p&gt; For String element, it will type to be parsed as integer&lt;/p&gt;
         * &lt;p&gt; Unsigned elements will become negative&lt;/p&gt;
         * &lt;p&gt; Float elements will be casted to integer &lt;/p&gt;
         * @return 64-bit integer or 0 if fail to convert element to long.
         */
        public long asLong() {
<span class="fc bfc" id="L425" title="All 2 branches covered.">            if (type == FBT_INT) {</span>
                // A fast path for the common case.
<span class="fc" id="L427">                return readLong(bb, end, parentWidth);</span>
            } else
<span class="pc bpc" id="L429" title="9 of 10 branches missed.">                switch (type) {</span>
<span class="nc" id="L430">                    case FBT_INDIRECT_INT: return readLong(bb, indirect(bb, end, parentWidth), byteWidth);</span>
<span class="nc" id="L431">                    case FBT_UINT: return readUInt(bb, end, parentWidth);</span>
<span class="nc" id="L432">                    case FBT_INDIRECT_UINT: return readUInt(bb, indirect(bb, end, parentWidth), parentWidth);</span>
<span class="nc" id="L433">                    case FBT_FLOAT: return (long) readDouble(bb, end, parentWidth);</span>
<span class="nc" id="L434">                    case FBT_INDIRECT_FLOAT: return (long) readDouble(bb, indirect(bb, end, parentWidth), byteWidth);</span>
<span class="nc" id="L435">                    case FBT_NULL: return 0;</span>
                    case FBT_STRING: {
                        try {
<span class="nc" id="L438">                            return Long.parseLong(asString());</span>
<span class="fc" id="L439">                        } catch (NumberFormatException nfe) {</span>
<span class="fc" id="L440">                            return 0; //same as C++ implementation</span>
                        }
                    }
<span class="nc" id="L443">                    case FBT_VECTOR: return asVector().size();</span>
<span class="nc" id="L444">                    case FBT_BOOL: return readInt(bb, end, parentWidth);</span>
                    default:
                        // Convert other things to int.
<span class="nc" id="L447">                        return 0;</span>
                }
        }

        /**
         * Returns element as 64-bit integer.
         * &lt;p&gt; For vector element, it will return size of the vector&lt;/p&gt;
         * &lt;p&gt; For String element, it will type to be parsed as integer&lt;/p&gt;
         * @return 64-bit integer or 0 if fail to convert element to long.
         */
        public double asFloat() {
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">            if (type == FBT_FLOAT) {</span>
                // A fast path for the common case.
<span class="fc" id="L460">                return readDouble(bb, end, parentWidth);</span>
            } else
<span class="nc bnc" id="L462" title="All 9 branches missed.">                switch (type) {</span>
<span class="nc" id="L463">                    case FBT_INDIRECT_FLOAT: return readDouble(bb, indirect(bb, end, parentWidth), byteWidth);</span>
<span class="nc" id="L464">                    case FBT_INT: return readInt(bb, end, parentWidth);</span>
                    case FBT_UINT:
                    case FBT_BOOL:
<span class="nc" id="L467">                        return readUInt(bb, end, parentWidth);</span>
<span class="nc" id="L468">                    case FBT_INDIRECT_INT: return readInt(bb, indirect(bb, end, parentWidth), byteWidth);</span>
<span class="nc" id="L469">                    case FBT_INDIRECT_UINT: return readUInt(bb, indirect(bb, end, parentWidth), byteWidth);</span>
<span class="nc" id="L470">                    case FBT_NULL: return 0.0;</span>
<span class="nc" id="L471">                    case FBT_STRING: return Double.parseDouble(asString());</span>
<span class="nc" id="L472">                    case FBT_VECTOR: return asVector().size();</span>
                    default:
                        // Convert strings and other things to float.
<span class="nc" id="L475">                        return 0;</span>
                }
        }

        /**
         * Returns element as a {@link Key}
         * @return key or {@link Key#empty()} if element is not a key
         */
        public Key asKey() {
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">            if (isKey()) {</span>
<span class="nc" id="L485">                return new Key(bb, indirect(bb, end, parentWidth), byteWidth);</span>
            } else {
<span class="fc" id="L487">                return Key.empty();</span>
            }
        }

        /**
         * Returns element as a `String`
         * @return element as `String` or empty `String` if fail
         */
        public String asString() {
<span class="fc bfc" id="L496" title="All 2 branches covered.">            if (isString()) {</span>
<span class="fc" id="L497">                int start = indirect(bb, end, parentWidth);</span>
<span class="fc" id="L498">                int size = (int) readUInt(bb, start - byteWidth, byteWidth);</span>
<span class="fc" id="L499">                return bb.getString(start, size);</span>
            }
<span class="fc bfc" id="L501" title="All 2 branches covered.">            else if (isKey()){</span>
<span class="fc" id="L502">                int start = indirect(bb, end, byteWidth);</span>
<span class="fc" id="L503">                for (int i = start; ; i++) {</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">                    if (bb.get(i) == 0) {</span>
<span class="fc" id="L505">                        return bb.getString(start, i - start);</span>
                    }
                }
            } else {
<span class="fc" id="L509">                return &quot;&quot;;</span>
            }
        }

        /**
         * Returns element as a {@link Map}
         * @return element as {@link Map} or empty {@link Map} if fail
         */
        public Map asMap() {
<span class="fc bfc" id="L518" title="All 2 branches covered.">            if (isMap()) {</span>
<span class="fc" id="L519">                return new Map(bb, indirect(bb, end, parentWidth), byteWidth);</span>
            } else {
<span class="fc" id="L521">                return Map.empty();</span>
            }
        }

        /**
         * Returns element as a {@link Vector}
         * @return element as {@link Vector} or empty {@link Vector} if fail
         */
        public Vector asVector() {
<span class="fc bfc" id="L530" title="All 2 branches covered.">            if (isVector()) {</span>
<span class="fc" id="L531">                return new Vector(bb, indirect(bb, end, parentWidth), byteWidth);</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">            } else if(type == FlexBuffers.FBT_VECTOR_STRING_DEPRECATED) {</span>
                // deprecated. Should be treated as key vector
<span class="fc" id="L534">                return new TypedVector(bb, indirect(bb, end, parentWidth), byteWidth, FlexBuffers.FBT_KEY);</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">            } else if (FlexBuffers.isTypedVector(type)) {</span>
<span class="fc" id="L536">                return new TypedVector(bb, indirect(bb, end, parentWidth), byteWidth, FlexBuffers.toTypedVectorElementType(type));</span>
            } else {
<span class="fc" id="L538">                return Vector.empty();</span>
            }
        }

        /**
         * Returns element as a {@link Blob}
         * @return element as {@link Blob} or empty {@link Blob} if fail
         */
        public Blob asBlob() {
<span class="pc bpc" id="L547" title="1 of 4 branches missed.">            if (isBlob() || isString()) {</span>
<span class="fc" id="L548">                return new Blob(bb, indirect(bb, end, parentWidth), byteWidth);</span>
            } else {
<span class="fc" id="L550">                return Blob.empty();</span>
            }
        }

        /**
         * Returns element as a boolean
         * &lt;p&gt;If element type is not boolean, it will be casted to integer and compared against 0&lt;/p&gt;
         * @return element as boolean
         */
        public boolean asBoolean() {
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">            if (isBoolean()) {</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">                return bb.get(end) != 0;</span>
            }
<span class="nc bnc" id="L563" title="All 2 branches missed.">            return asUInt() != 0;</span>
        }

        /**
         * Returns text representation of the element (JSON)
         * @return String containing text representation of the element
         */
        @Override
        public String toString() {
<span class="fc" id="L572">            return toString(new StringBuilder(128)).toString();</span>
        }

        /**
         * Appends a text(JSON) representation to a `StringBuilder`
         */
        StringBuilder toString(StringBuilder sb) {
            //TODO: Original C++ implementation escape strings.
            // probably we should do it as well.
<span class="pc bpc" id="L581" title="7 of 13 branches missed.">            switch (type) {</span>
                case FBT_NULL:
<span class="nc" id="L583">                    return sb.append(&quot;null&quot;);</span>
                case FBT_INT:
                case FBT_INDIRECT_INT:
<span class="fc" id="L586">                    return sb.append(asLong());</span>
                case FBT_UINT:
                case FBT_INDIRECT_UINT:
<span class="nc" id="L589">                    return sb.append(asUInt());</span>
                case FBT_INDIRECT_FLOAT:
                case FBT_FLOAT:
<span class="fc" id="L592">                    return sb.append(asFloat());</span>
                case FBT_KEY:
<span class="nc" id="L594">                    return asKey().toString(sb.append('&quot;')).append('&quot;');</span>
                case FBT_STRING:
<span class="fc" id="L596">                    return sb.append('&quot;').append(asString()).append('&quot;');</span>
                case FBT_MAP:
<span class="fc" id="L598">                    return asMap().toString(sb);</span>
                case FBT_VECTOR:
<span class="fc" id="L600">                    return asVector().toString(sb);</span>
                case FBT_BLOB:
<span class="fc" id="L602">                    return asBlob().toString(sb);</span>
                case FBT_BOOL:
<span class="nc" id="L604">                    return sb.append(asBoolean());</span>
                case FBT_VECTOR_INT:
                case FBT_VECTOR_UINT:
                case FBT_VECTOR_FLOAT:
                case FBT_VECTOR_KEY:
                case FBT_VECTOR_STRING_DEPRECATED:
                case FBT_VECTOR_BOOL:
<span class="nc" id="L611">                    return sb.append(asVector());</span>
                case FBT_VECTOR_INT2:
                case FBT_VECTOR_UINT2:
                case FBT_VECTOR_FLOAT2:
                case FBT_VECTOR_INT3:
                case FBT_VECTOR_UINT3:
                case FBT_VECTOR_FLOAT3:
                case FBT_VECTOR_INT4:
                case FBT_VECTOR_UINT4:
                case FBT_VECTOR_FLOAT4:

<span class="nc" id="L622">                    throw new FlexBufferException(&quot;not_implemented:&quot; + type);</span>
                default:
<span class="nc" id="L624">                    return sb;</span>
            }
        }
    }

    /**
     * Base class of all types below.
     * Points into the data buffer and allows access to one type.
     */
    private static abstract class Object {
        ReadBuf bb;
        int end;
        int byteWidth;

<span class="fc" id="L638">        Object(ReadBuf buff, int end, int byteWidth) {</span>
<span class="fc" id="L639">            this.bb = buff;</span>
<span class="fc" id="L640">            this.end = end;</span>
<span class="fc" id="L641">            this.byteWidth = byteWidth;</span>
<span class="fc" id="L642">        }</span>

        @Override
        public String toString() {
<span class="nc" id="L646">            return toString(new StringBuilder(128)).toString();</span>
        }

        public abstract StringBuilder toString(StringBuilder sb);
    }

    // Stores size in `byte_width_` bytes before end position.
    private static abstract class Sized extends Object {

        protected final int size;

        Sized(ReadBuf buff, int end, int byteWidth) {
<span class="fc" id="L658">            super(buff, end, byteWidth);</span>
<span class="fc" id="L659">            size = (int) readUInt(bb, end - byteWidth, byteWidth);</span>
<span class="fc" id="L660">        }</span>

        public int size() {
<span class="fc" id="L663">            return size;</span>
        }
    }

    /**
     * Represents a array of bytes element in the buffer
     *
     * &lt;p&gt;It can be converted to `ReadBuf` using {@link data()},
     * copied into a byte[] using {@link getBytes()} or
     * have individual bytes accessed individually using {@link get(int)}&lt;/p&gt;
     */
<span class="pc bpc" id="L674" title="1 of 2 branches missed.">    public static class Blob extends Sized {</span>
<span class="fc" id="L675">        static final Blob EMPTY = new Blob(EMPTY_BB, 1, 1);</span>

        Blob(ReadBuf buff, int end, int byteWidth) {
<span class="fc" id="L678">            super(buff, end, byteWidth);</span>
<span class="fc" id="L679">        }</span>

        /** Return an empty {@link Blob} */
        public static Blob empty() {
<span class="fc" id="L683">            return EMPTY;</span>
        }

        /**
         * Return {@link Blob} as `ReadBuf`
         * @return blob as `ReadBuf`
         */
        public ByteBuffer data() {
<span class="fc" id="L691">            ByteBuffer dup = ByteBuffer.wrap(bb.data());</span>
<span class="fc" id="L692">            dup.position(end);</span>
<span class="fc" id="L693">            dup.limit(end + size());</span>
<span class="fc" id="L694">            return dup.asReadOnlyBuffer().slice();</span>
        }

        /**
         * Copy blob into a byte[]
         * @return blob as a byte[]
         */
        public byte[] getBytes() {
<span class="fc" id="L702">            int size = size();</span>
<span class="fc" id="L703">            byte[] result = new byte[size];</span>
<span class="fc bfc" id="L704" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L705">                result[i] = bb.get(end + i);</span>
            }
<span class="fc" id="L707">            return result;</span>
        }

        /**
         * Return individual byte at a given position
         * @param pos position of the byte to be read
         */
        public byte get(int pos) {
<span class="nc bnc" id="L715" title="All 6 branches missed.">            assert pos &gt;=0 &amp;&amp; pos &lt;= size();</span>
<span class="nc" id="L716">            return bb.get(end + pos);</span>
        }

        /**
         * Returns a text(JSON) representation of the {@link Blob}
         */
        @Override
        public String toString() {
<span class="fc" id="L724">            return bb.getString(end, size());</span>
        }

        /**
         * Append a text(JSON) representation of the {@link Blob} into a `StringBuilder`
         */
        @Override
        public StringBuilder toString(StringBuilder sb) {
<span class="fc" id="L732">            sb.append('&quot;');</span>
<span class="fc" id="L733">            sb.append(bb.getString(end, size()));</span>
<span class="fc" id="L734">            return sb.append('&quot;');</span>
        }
    }

    /**
     * Represents a key element in the buffer. Keys are
     * used to reference objects in a {@link Map}
     */
    public static class Key extends Object {

<span class="fc" id="L744">        private static final Key EMPTY = new Key(EMPTY_BB, 0, 0);</span>

        Key(ReadBuf buff, int end, int byteWidth) {
<span class="fc" id="L747">            super(buff, end, byteWidth);</span>
<span class="fc" id="L748">        }</span>

        /**
         * Return an empty {@link Key}
         * @return empty {@link Key}
         * */
        public static Key empty() {
<span class="fc" id="L755">            return Key.EMPTY;</span>
        }

        /**
         * Appends a text(JSON) representation to a `StringBuilder`
         */
        @Override
        public StringBuilder toString(StringBuilder sb) {
<span class="nc" id="L763">            return sb.append(toString());</span>
        }

        @Override
        public String toString() {
            int size;
<span class="fc" id="L769">            for (int i = end; ; i++) {</span>
<span class="fc bfc" id="L770" title="All 2 branches covered.">                if (bb.get(i) == 0) {</span>
<span class="fc" id="L771">                    size = i - end;</span>
<span class="fc" id="L772">                    break;</span>
                }
            }
<span class="fc" id="L775">            return bb.getString(end, size);</span>
        }

        int compareTo(byte[] other) {
<span class="nc" id="L779">            int ia = end;</span>
<span class="nc" id="L780">            int io = 0;</span>
            byte c1, c2;
            do {
<span class="nc" id="L783">                c1 = bb.get(ia);</span>
<span class="nc" id="L784">                c2 = other[io];</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">                if (c1 == '\0')</span>
<span class="nc" id="L786">                    return c1 - c2;</span>
<span class="nc" id="L787">                ia++;</span>
<span class="nc" id="L788">                io++;</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">                if (io == other.length) {</span>
                    // in our buffer we have an additional \0 byte
                    // but this does not exist in regular Java strings, so we return now
<span class="nc" id="L792">                    int cmp = c1 - c2;</span>
<span class="nc bnc" id="L793" title="All 4 branches missed.">                    if (cmp != 0 || bb.get(ia) == '\0') {</span>
<span class="nc" id="L794">                        return cmp;</span>
                    } else {
<span class="nc" id="L796">                        return 1;</span>
                    }
                }
            }
<span class="nc bnc" id="L800" title="All 2 branches missed.">            while (c1 == c2);</span>
<span class="nc" id="L801">            return c1 - c2;</span>
        }

        /**
         *  Compare keys
         *  @param obj other key to compare
         *  @return true if keys are the same
         */
        @Override
        public boolean equals(java.lang.Object obj) {
<span class="pc bpc" id="L811" title="1 of 2 branches missed.">            if (!(obj instanceof Key))</span>
<span class="nc" id="L812">                return false;</span>

<span class="pc bpc" id="L814" title="2 of 4 branches missed.">            return ((Key) obj).end == end &amp;&amp; ((Key) obj).byteWidth == byteWidth;</span>
        }

        public int hashCode() {
<span class="nc" id="L818">          return end ^ byteWidth;</span>
        }
    }

    /**
     * Map object representing a set of key-value pairs.
     */
    public static class Map extends Vector {
<span class="fc" id="L826">        private static final Map EMPTY_MAP = new Map(EMPTY_BB, 1, 1);</span>
        // cache for converting UTF-8 codepoints into
        // Java chars. Used to speed up String comparison
<span class="fc" id="L829">        private final byte[] comparisonBuffer = new byte[4];</span>

        Map(ReadBuf bb, int end, int byteWidth) {
<span class="fc" id="L832">            super(bb, end, byteWidth);</span>
<span class="fc" id="L833">        }</span>

        /**
         * Returns an empty {@link Map}
         * @return an empty {@link Map}
         */
        public static Map empty() {
<span class="fc" id="L840">            return EMPTY_MAP;</span>
        }

        /**
         * @param key access key to element on map
         * @return reference to value in map
         */
        public Reference get(String key) {
<span class="fc" id="L848">            int index = binarySearch(key);</span>
<span class="pc bpc" id="L849" title="1 of 4 branches missed.">            if (index &gt;= 0 &amp;&amp; index &lt; size) {</span>
<span class="fc" id="L850">                return get(index);</span>
            }
<span class="fc" id="L852">            return Reference.NULL_REFERENCE;</span>
        }

        /**
         * @param key access key to element on map. Keys are assumed to be encoded in UTF-8
         * @return reference to value in map
         */
        public Reference get(byte[] key) {
<span class="fc" id="L860">            int index = binarySearch(key);</span>
<span class="pc bpc" id="L861" title="2 of 4 branches missed.">            if (index &gt;= 0 &amp;&amp; index &lt; size) {</span>
<span class="fc" id="L862">                return get(index);</span>
            }
<span class="nc" id="L864">            return Reference.NULL_REFERENCE;</span>
        }

        /**
         * Get a vector or keys in the map
         *
         * @return vector of keys
         */
        public KeyVector keys() {
<span class="fc" id="L873">            final int num_prefixed_fields = 3;</span>
<span class="fc" id="L874">            int keysOffset = end - (byteWidth * num_prefixed_fields);</span>
<span class="fc" id="L875">            return new KeyVector(new TypedVector(bb,</span>
<span class="fc" id="L876">                    indirect(bb, keysOffset, byteWidth),</span>
<span class="fc" id="L877">                    readInt(bb, keysOffset + byteWidth, byteWidth),</span>
                    FBT_KEY));
        }

        /**
         * @return {@code Vector} of values from map
         */
        public Vector values() {
<span class="fc" id="L885">            return new Vector(bb, end, byteWidth);</span>
        }

        /**
         * Writes text (json) representation of map in a {@code StringBuilder}.
         *
         * @param builder {@code StringBuilder} to be appended to
         * @return Same {@code StringBuilder} with appended text
         */
        public StringBuilder toString(StringBuilder builder) {
<span class="fc" id="L895">            builder.append(&quot;{ &quot;);</span>
<span class="fc" id="L896">            KeyVector keys = keys();</span>
<span class="fc" id="L897">            int size = size();</span>
<span class="fc" id="L898">            Vector vals = values();</span>
<span class="fc bfc" id="L899" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L900">                builder.append('&quot;')</span>
<span class="fc" id="L901">                        .append(keys.get(i).toString())</span>
<span class="fc" id="L902">                        .append(&quot;\&quot; : &quot;);</span>
<span class="fc" id="L903">                builder.append(vals.get(i).toString());</span>
<span class="fc bfc" id="L904" title="All 2 branches covered.">                if (i != size - 1)</span>
<span class="fc" id="L905">                    builder.append(&quot;, &quot;);</span>
            }
<span class="fc" id="L907">            builder.append(&quot; }&quot;);</span>
<span class="fc" id="L908">            return builder;</span>
        }

        // Performs a binary search on a key vector and return index of the key in key vector
        private int binarySearch(CharSequence searchedKey) {
<span class="fc" id="L913">            int low = 0;</span>
<span class="fc" id="L914">            int high = size - 1;</span>
<span class="fc" id="L915">            final int num_prefixed_fields = 3;</span>
<span class="fc" id="L916">            int keysOffset = end - (byteWidth * num_prefixed_fields);</span>
<span class="fc" id="L917">            int keysStart = indirect(bb, keysOffset, byteWidth);</span>
<span class="fc" id="L918">            int keyByteWidth = readInt(bb, keysOffset + byteWidth, byteWidth);</span>
<span class="fc bfc" id="L919" title="All 2 branches covered.">            while (low &lt;= high) {</span>
<span class="fc" id="L920">                int mid = (low + high) &gt;&gt;&gt; 1;</span>
<span class="fc" id="L921">                int keyPos = indirect(bb, keysStart + mid * keyByteWidth, keyByteWidth);</span>
<span class="fc" id="L922">                int cmp = compareCharSequence(keyPos, searchedKey);</span>
<span class="fc bfc" id="L923" title="All 2 branches covered.">                if (cmp &lt; 0)</span>
<span class="fc" id="L924">                    low = mid + 1;</span>
<span class="fc bfc" id="L925" title="All 2 branches covered.">                else if (cmp &gt; 0)</span>
<span class="fc" id="L926">                    high = mid - 1;</span>
                else
<span class="fc" id="L928">                    return mid; // key found</span>
<span class="fc" id="L929">            }</span>
<span class="fc" id="L930">            return -(low + 1);  // key not found</span>
        }

        private int binarySearch(byte[] searchedKey) {
<span class="fc" id="L934">            int low = 0;</span>
<span class="fc" id="L935">            int high = size - 1;</span>
<span class="fc" id="L936">            final int num_prefixed_fields = 3;</span>
<span class="fc" id="L937">            int keysOffset = end - (byteWidth * num_prefixed_fields);</span>
<span class="fc" id="L938">            int keysStart = indirect(bb, keysOffset, byteWidth);</span>
<span class="fc" id="L939">            int keyByteWidth = readInt(bb, keysOffset + byteWidth, byteWidth);</span>

<span class="pc bpc" id="L941" title="1 of 2 branches missed.">            while (low &lt;= high) {</span>
<span class="fc" id="L942">                int mid = (low + high) &gt;&gt;&gt; 1;</span>
<span class="fc" id="L943">                int keyPos = indirect(bb, keysStart + mid * keyByteWidth, keyByteWidth);</span>
<span class="fc" id="L944">                int cmp = compareBytes(bb, keyPos, searchedKey);</span>
<span class="fc bfc" id="L945" title="All 2 branches covered.">                if (cmp &lt; 0)</span>
<span class="fc" id="L946">                    low = mid + 1;</span>
<span class="fc bfc" id="L947" title="All 2 branches covered.">                else if (cmp &gt; 0)</span>
<span class="fc" id="L948">                    high = mid - 1;</span>
                else
<span class="fc" id="L950">                    return mid; // key found</span>
<span class="fc" id="L951">            }</span>
<span class="nc" id="L952">            return -(low + 1);  // key not found</span>
        }

        // compares a byte[] against a FBT_KEY
        private int compareBytes(ReadBuf bb, int start, byte[] other) {
<span class="fc" id="L957">            int l1 = start;</span>
<span class="fc" id="L958">            int l2 = 0;</span>
            byte c1, c2;
            do {
<span class="fc" id="L961">                c1 = bb.get(l1);</span>
<span class="fc" id="L962">                c2 = other[l2];</span>
<span class="fc bfc" id="L963" title="All 2 branches covered.">                if (c1 == '\0')</span>
<span class="fc" id="L964">                    return c1 - c2;</span>
<span class="fc" id="L965">                l1++;</span>
<span class="fc" id="L966">                l2++;</span>
<span class="fc bfc" id="L967" title="All 2 branches covered.">                if (l2 == other.length) {</span>
                    // in our buffer we have an additional \0 byte
                    // but this does not exist in regular Java strings, so we return now
<span class="fc" id="L970">                    int cmp = c1 - c2;</span>
<span class="pc bpc" id="L971" title="1 of 4 branches missed.">                    if (cmp != 0 || bb.get(l1) == '\0') {</span>
<span class="fc" id="L972">                        return cmp;</span>
                    } else {
<span class="fc" id="L974">                        return 1;</span>
                    }
                }
            }
<span class="pc bpc" id="L978" title="1 of 2 branches missed.">            while (c1 == c2);</span>
<span class="nc" id="L979">            return c1 - c2;</span>
        }

        // compares a CharSequence against a FBT_KEY
        private int compareCharSequence(int start, CharSequence other) {
<span class="fc" id="L984">            int bufferPos = start;</span>
<span class="fc" id="L985">            int otherPos = 0;</span>
<span class="fc" id="L986">            int limit = bb.limit();</span>
<span class="fc" id="L987">            int otherLimit = other.length();</span>

            // special loop for ASCII characters. Most of keys should be ASCII only, so this
            // loop should be optimized for that.
            // breaks if a multi-byte character is found
<span class="fc bfc" id="L992" title="All 2 branches covered.">            while (otherPos &lt; otherLimit) {</span>
<span class="fc" id="L993">                char c2 = other.charAt(otherPos);</span>

<span class="fc bfc" id="L995" title="All 2 branches covered.">                if (c2 &gt;= 0x80) {</span>
                    // not a single byte codepoint
<span class="fc" id="L997">                    break;</span>
                }

<span class="fc" id="L1000">                byte b = bb.get(bufferPos);</span>

<span class="fc bfc" id="L1002" title="All 2 branches covered.">                if (b == 0) {</span>
<span class="fc" id="L1003">                    return -c2;</span>
<span class="fc bfc" id="L1004" title="All 2 branches covered.">                } else if (b &lt; 0) {</span>
<span class="fc" id="L1005">                    break;</span>
<span class="fc bfc" id="L1006" title="All 2 branches covered.">                } else if ((char) b != c2) {</span>
<span class="fc" id="L1007">                    return b - c2;</span>
                }
<span class="fc" id="L1009">                ++bufferPos;</span>
<span class="fc" id="L1010">                ++otherPos;</span>
<span class="fc" id="L1011">            }</span>

<span class="pc bpc" id="L1013" title="1 of 2 branches missed.">            while (bufferPos &lt; limit) {</span>

<span class="fc" id="L1015">                int sizeInBuff = Utf8.encodeUtf8CodePoint(other, otherPos, comparisonBuffer);</span>

<span class="fc bfc" id="L1017" title="All 2 branches covered.">                if (sizeInBuff == 0) {</span>
                    // That means we finish with other and there are not more chars to
                    // compare. String in the buffer is bigger.
<span class="fc" id="L1020">                    return bb.get(bufferPos);</span>
                }

<span class="fc bfc" id="L1023" title="All 2 branches covered.">                for (int i = 0; i &lt; sizeInBuff; i++) {</span>
<span class="fc" id="L1024">                    byte bufferByte = bb.get(bufferPos++);</span>
<span class="fc" id="L1025">                    byte otherByte = comparisonBuffer[i];</span>
<span class="pc bpc" id="L1026" title="1 of 2 branches missed.">                    if (bufferByte == 0) {</span>
                        // Our key is finished, so other is bigger
<span class="nc" id="L1028">                        return -otherByte;</span>
<span class="fc bfc" id="L1029" title="All 2 branches covered.">                    } else if (bufferByte != otherByte) {</span>
<span class="fc" id="L1030">                        return bufferByte - otherByte;</span>
                    }
                }

<span class="fc bfc" id="L1034" title="All 2 branches covered.">                otherPos += sizeInBuff == 4 ? 2 : 1;</span>
<span class="fc" id="L1035">            }</span>
<span class="nc" id="L1036">            return 0;</span>
        }
    }

    /**
     * Object that represents a set of elements in the buffer
     */
    public static class Vector extends Sized {

<span class="fc" id="L1045">        private static final Vector EMPTY_VECTOR = new Vector(EMPTY_BB, 1, 1);</span>

        Vector(ReadBuf bb, int end, int byteWidth) {
<span class="fc" id="L1048">            super(bb, end, byteWidth);</span>
<span class="fc" id="L1049">        }</span>

        /**
         * Returns an empty {@link Map}
         * @return an empty {@link Map}
         */
        public static Vector empty() {
<span class="fc" id="L1056">            return EMPTY_VECTOR;</span>
        }

        /**
         * Checks if the vector is empty
         * @return true if vector is empty
         */
        public boolean isEmpty() {
<span class="pc bpc" id="L1064" title="1 of 2 branches missed.">            return this == EMPTY_VECTOR;</span>
        }

        /**
         * Appends a text(JSON) representation to a `StringBuilder`
         */
        @Override
        public StringBuilder toString(StringBuilder sb) {
<span class="fc" id="L1072">            sb.append(&quot;[ &quot;);</span>
<span class="fc" id="L1073">            int size = size();</span>
<span class="fc bfc" id="L1074" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L1075">                get(i).toString(sb);</span>
<span class="fc bfc" id="L1076" title="All 2 branches covered.">                if (i != size - 1) {</span>
<span class="fc" id="L1077">                    sb.append(&quot;, &quot;);</span>
                }
            }
<span class="fc" id="L1080">            sb.append(&quot; ]&quot;);</span>
<span class="fc" id="L1081">            return sb;</span>
        }

        /**
         * Get a element in a vector by index
         *
         * @param index position of the element
         * @return {@code Reference} to the element
         */
        public Reference get(int index) {
<span class="fc" id="L1091">            long len = size();</span>
<span class="pc bpc" id="L1092" title="1 of 2 branches missed.">            if (index &gt;= len) {</span>
<span class="nc" id="L1093">                return Reference.NULL_REFERENCE;</span>
            }
<span class="fc" id="L1095">            int packedType = byteToUnsignedInt(bb.get((int) (end + (len * byteWidth) + index)));</span>
<span class="fc" id="L1096">            int obj_end = end + index * byteWidth;</span>
<span class="fc" id="L1097">            return new Reference(bb, obj_end, byteWidth, packedType);</span>
        }
    }

    /**
     * Object that represents a set of elements with the same type
     */
    public static class TypedVector extends Vector {

<span class="fc" id="L1106">        private static final TypedVector EMPTY_VECTOR = new TypedVector(EMPTY_BB, 1, 1, FBT_INT);</span>

        private final int elemType;

        TypedVector(ReadBuf bb, int end, int byteWidth, int elemType) {
<span class="fc" id="L1111">            super(bb, end, byteWidth);</span>
<span class="fc" id="L1112">            this.elemType = elemType;</span>
<span class="fc" id="L1113">        }</span>

        public static TypedVector empty() {
<span class="fc" id="L1116">            return EMPTY_VECTOR;</span>
        }

        /**
         * Returns whether the vector is empty
         *
         * @return true if empty
         */
        public boolean isEmptyVector() {
<span class="nc bnc" id="L1125" title="All 2 branches missed.">            return this == EMPTY_VECTOR;</span>
        }

        /**
         * Return element type for all elements in the vector
         *
         * @return element type
         */
        public int getElemType() {
<span class="fc" id="L1134">            return elemType;</span>
        }

        /**
         * Get reference to an object in the {@code Vector}
         *
         * @param pos position of the object in {@code Vector}
         * @return reference to element
         */
        @Override
        public Reference get(int pos) {
<span class="fc" id="L1145">            int len = size();</span>
<span class="pc bpc" id="L1146" title="1 of 2 branches missed.">            if (pos &gt;= len) return Reference.NULL_REFERENCE;</span>
<span class="fc" id="L1147">            int childPos = end + pos * byteWidth;</span>
<span class="fc" id="L1148">            return new Reference(bb, childPos, byteWidth, 1, elemType);</span>
        }
    }

    /**
     * Represent a vector of keys in a map
     */
    public static class KeyVector {

        private final TypedVector vec;

<span class="fc" id="L1159">        KeyVector(TypedVector vec) {</span>
<span class="fc" id="L1160">            this.vec = vec;</span>
<span class="fc" id="L1161">        }</span>

        /**
         * Return key
         *
         * @param pos position of the key in key vector
         * @return key
         */
        public Key get(int pos) {
<span class="fc" id="L1170">            int len = size();</span>
<span class="pc bpc" id="L1171" title="1 of 2 branches missed.">            if (pos &gt;= len) return Key.EMPTY;</span>
<span class="fc" id="L1172">            int childPos = vec.end + pos * vec.byteWidth;</span>
<span class="fc" id="L1173">            return new Key(vec.bb, indirect(vec.bb, childPos, vec.byteWidth), 1);</span>
        }

        /**
         * Returns size of key vector
         *
         * @return size
         */
        public int size() {
<span class="fc" id="L1182">            return vec.size();</span>
        }

        /**
         * Returns a text(JSON) representation
         */
        public String toString() {
<span class="nc" id="L1189">            StringBuilder b = new StringBuilder();</span>
<span class="nc" id="L1190">            b.append('[');</span>
<span class="nc bnc" id="L1191" title="All 2 branches missed.">            for (int i = 0; i &lt; vec.size(); i++) {</span>
<span class="nc" id="L1192">                vec.get(i).toString(b);</span>
<span class="nc bnc" id="L1193" title="All 2 branches missed.">                if (i != vec.size() - 1) {</span>
<span class="nc" id="L1194">                    b.append(&quot;, &quot;);</span>
                }
            }
<span class="nc" id="L1197">            return b.append(&quot;]&quot;).toString();</span>
        }
    }

    public static class FlexBufferException extends RuntimeException {
        FlexBufferException(String msg) {
<span class="fc" id="L1203">            super(msg);</span>
<span class="fc" id="L1204">        }</span>
    }

<span class="nc" id="L1207">    static class Unsigned {</span>

        static int byteToUnsignedInt(byte x) {
<span class="fc" id="L1210">            return ((int) x) &amp; 0xff;</span>
        }

        static int shortToUnsignedInt(short x) {
<span class="fc" id="L1214">            return ((int) x) &amp; 0xffff;</span>
        }

        static long intToUnsignedLong(int x) {
<span class="fc" id="L1218">            return ((long) x) &amp; 0xffffffffL;</span>
        }
    }
}
/// @}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>