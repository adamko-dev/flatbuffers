<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Utf8.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">flatbuffers</a> &gt; <a href="index.source.html" class="el_package">com.google.flatbuffers</a> &gt; <span class="el_source">Utf8.java</span></div><h1>Utf8.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2014 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.flatbuffers;

import java.nio.ByteBuffer;

import static java.lang.Character.MAX_SURROGATE;
import static java.lang.Character.MIN_SURROGATE;
import static java.lang.Character.MIN_HIGH_SURROGATE;
import static java.lang.Character.MIN_LOW_SURROGATE;
import static java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT;
import static java.lang.Character.isSurrogatePair;
import static java.lang.Character.toCodePoint;

<span class="pc bpc" id="L29" title="1 of 2 branches missed.">public abstract class Utf8 {</span>

  /**
   * Returns the number of bytes in the UTF-8-encoded form of {@code sequence}. For a string,
   * this method is equivalent to {@code string.getBytes(UTF_8).length}, but is more efficient in
   * both time and space.
   *
   * @throws IllegalArgumentException if {@code sequence} contains ill-formed UTF-16 (unpaired
   *     surrogates)
   */
  public abstract int encodedLength(CharSequence sequence);

  /**
   * Encodes the given characters to the target {@link ByteBuffer} using UTF-8 encoding.
   *
   * &lt;p&gt;Selects an optimal algorithm based on the type of {@link ByteBuffer} (i.e. heap or direct)
   * and the capabilities of the platform.
   *
   * @param in the source string to be encoded
   * @param out the target buffer to receive the encoded string.
   */
  public abstract void encodeUtf8(CharSequence in, ByteBuffer out);

  /**
   * Decodes the given UTF-8 portion of the {@link ByteBuffer} into a {@link String}.
   *
   * @throws IllegalArgumentException if the input is not valid UTF-8.
   */
  public abstract String decodeUtf8(ByteBuffer buffer, int offset, int length);

  private static Utf8 DEFAULT;

  /**
   * Get the default UTF-8 processor.
   * @return the default processor
   */
  public static Utf8 getDefault() {
<span class="fc bfc" id="L66" title="All 2 branches covered.">    if (DEFAULT == null) {</span>
<span class="fc" id="L67">      DEFAULT = new Utf8Safe();</span>
    }
<span class="fc" id="L69">    return DEFAULT;</span>
  }

  /**
   * Set the default instance of the UTF-8 processor.
   * @param instance the new instance to use
   */
  public static void setDefault(Utf8 instance) {
<span class="nc" id="L77">    DEFAULT = instance;</span>
<span class="nc" id="L78">  }</span>

  /**
   * Encode a Java's CharSequence UTF8 codepoint into a byte array.
   * @param in CharSequence to be encoded
   * @param start start position of the first char in the codepoint
   * @param out byte array of 4 bytes to be filled
   * @return return the amount of bytes occupied by the codepoint
   */
  public static int encodeUtf8CodePoint(CharSequence in, int start, byte[] out) {
    // utf8 codepoint needs at least 4 bytes
<span class="pc bpc" id="L89" title="2 of 4 branches missed.">    assert out.length &gt;= 4;</span>

<span class="fc" id="L91">    final int inLength = in.length();</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">    if (start &gt;= inLength) {</span>
<span class="fc" id="L93">      return 0;</span>
    }

<span class="fc" id="L96">    char c = in.charAt(start);</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">     if (c &lt; 0x80) {</span>
       // One byte (0xxx xxxx)
<span class="fc" id="L99">       out[0] = (byte) c;</span>
<span class="fc" id="L100">       return 1;</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">     } else if (c &lt; 0x800) {</span>
      // Two bytes (110x xxxx 10xx xxxx)
<span class="fc" id="L103">      out[0] = (byte) (0xC0 | (c &gt;&gt;&gt; 6));</span>
<span class="fc" id="L104">      out[1] = (byte) (0x80 | (0x3F &amp; c));</span>
<span class="fc" id="L105">      return 2;</span>
<span class="pc bpc" id="L106" title="1 of 4 branches missed.">    } else if (c &lt; MIN_SURROGATE || MAX_SURROGATE &lt; c) {</span>
      // Three bytes (1110 xxxx 10xx xxxx 10xx xxxx)
      // Maximum single-char code point is 0xFFFF, 16 bits.
<span class="fc" id="L109">      out[0] = (byte) (0xE0 | (c &gt;&gt;&gt; 12));</span>
<span class="fc" id="L110">      out[1] =(byte) (0x80 | (0x3F &amp; (c &gt;&gt;&gt; 6)));</span>
<span class="fc" id="L111">      out[2] = (byte) (0x80 | (0x3F &amp; c));</span>
<span class="fc" id="L112">      return 3;</span>
    } else {
      // Four bytes (1111 xxxx 10xx xxxx 10xx xxxx 10xx xxxx)
      // Minimum code point represented by a surrogate pair is 0x10000, 17 bits, four UTF-8
      // bytes
      final char low;
<span class="pc bpc" id="L118" title="2 of 4 branches missed.">      if (start + 1 == inLength || !isSurrogatePair(c, (low = in.charAt(start+1)))) {</span>
<span class="nc" id="L119">        throw new UnpairedSurrogateException(start, inLength);</span>
      }
<span class="fc" id="L121">      int codePoint = toCodePoint(c, low);</span>
<span class="fc" id="L122">      out[0] = (byte) ((0xF &lt;&lt; 4) | (codePoint &gt;&gt;&gt; 18));</span>
<span class="fc" id="L123">      out[1] = (byte) (0x80 | (0x3F &amp; (codePoint &gt;&gt;&gt; 12)));</span>
<span class="fc" id="L124">      out[2] = (byte) (0x80 | (0x3F &amp; (codePoint &gt;&gt;&gt; 6)));</span>
<span class="fc" id="L125">      out[3] = (byte) (0x80 | (0x3F &amp; codePoint));</span>
<span class="fc" id="L126">      return 4;</span>
    }
  }

  /**
   * Utility methods for decoding bytes into {@link String}. Callers are responsible for extracting
   * bytes (possibly using Unsafe methods), and checking remaining bytes. All other UTF-8 validity
   * checks and codepoint conversion happen in this class.
   */
<span class="nc" id="L135">  static class DecodeUtil {</span>

    /**
     * Returns whether this is a single-byte codepoint (i.e., ASCII) with the form '0XXXXXXX'.
     */
    static boolean isOneByte(byte b) {
<span class="fc bfc" id="L141" title="All 2 branches covered.">      return b &gt;= 0;</span>
    }

    /**
     * Returns whether this is a two-byte codepoint with the form '10XXXXXX'.
     */
    static boolean isTwoBytes(byte b) {
<span class="fc bfc" id="L148" title="All 2 branches covered.">      return b &lt; (byte) 0xE0;</span>
    }

    /**
     * Returns whether this is a three-byte codepoint with the form '110XXXXX'.
     */
    static boolean isThreeBytes(byte b) {
<span class="fc bfc" id="L155" title="All 2 branches covered.">      return b &lt; (byte) 0xF0;</span>
    }

    static void handleOneByte(byte byte1, char[] resultArr, int resultPos) {
<span class="fc" id="L159">      resultArr[resultPos] = (char) byte1;</span>
<span class="fc" id="L160">    }</span>

    static void handleTwoBytes(
        byte byte1, byte byte2, char[] resultArr, int resultPos)
        throws IllegalArgumentException {
      // Simultaneously checks for illegal trailing-byte in leading position (&lt;= '11000000') and
      // overlong 2-byte, '11000001'.
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">      if (byte1 &lt; (byte) 0xC2) {</span>
<span class="nc" id="L168">        throw new IllegalArgumentException(&quot;Invalid UTF-8: Illegal leading byte in 2 bytes utf&quot;);</span>
      }
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">      if (isNotTrailingByte(byte2)) {</span>
<span class="nc" id="L171">        throw new IllegalArgumentException(&quot;Invalid UTF-8: Illegal trailing byte in 2 bytes utf&quot;);</span>
      }
<span class="fc" id="L173">      resultArr[resultPos] = (char) (((byte1 &amp; 0x1F) &lt;&lt; 6) | trailingByteValue(byte2));</span>
<span class="fc" id="L174">    }</span>

    static void handleThreeBytes(
        byte byte1, byte byte2, byte byte3, char[] resultArr, int resultPos)
        throws IllegalArgumentException {
<span class="pc bpc" id="L179" title="7 of 10 branches missed.">      if (isNotTrailingByte(byte2)</span>
              // overlong? 5 most significant bits must not all be zero
              || (byte1 == (byte) 0xE0 &amp;&amp; byte2 &lt; (byte) 0xA0)
              // check for illegal surrogate codepoints
              || (byte1 == (byte) 0xED &amp;&amp; byte2 &gt;= (byte) 0xA0)
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">              || isNotTrailingByte(byte3)) {</span>
<span class="nc" id="L185">        throw new IllegalArgumentException(&quot;Invalid UTF-8&quot;);</span>
      }
<span class="fc" id="L187">      resultArr[resultPos] = (char)</span>
<span class="fc" id="L188">                                 (((byte1 &amp; 0x0F) &lt;&lt; 12) | (trailingByteValue(byte2) &lt;&lt; 6) | trailingByteValue(byte3));</span>
<span class="fc" id="L189">    }</span>

    static void handleFourBytes(
        byte byte1, byte byte2, byte byte3, byte byte4, char[] resultArr, int resultPos)
        throws IllegalArgumentException{
<span class="pc bpc" id="L194" title="2 of 4 branches missed.">      if (isNotTrailingByte(byte2)</span>
              // Check that 1 &lt;= plane &lt;= 16.  Tricky optimized form of:
              //   valid 4-byte leading byte?
              // if (byte1 &gt; (byte) 0xF4 ||
              //   overlong? 4 most significant bits must not all be zero
              //     byte1 == (byte) 0xF0 &amp;&amp; byte2 &lt; (byte) 0x90 ||
              //   codepoint larger than the highest code point (U+10FFFF)?
              //     byte1 == (byte) 0xF4 &amp;&amp; byte2 &gt; (byte) 0x8F)
              || (((byte1 &lt;&lt; 28) + (byte2 - (byte) 0x90)) &gt;&gt; 30) != 0
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">              || isNotTrailingByte(byte3)</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">              || isNotTrailingByte(byte4)) {</span>
<span class="nc" id="L205">        throw new IllegalArgumentException(&quot;Invalid UTF-8&quot;);</span>
      }
<span class="fc" id="L207">      int codepoint = ((byte1 &amp; 0x07) &lt;&lt; 18)</span>
<span class="fc" id="L208">                          | (trailingByteValue(byte2) &lt;&lt; 12)</span>
<span class="fc" id="L209">                          | (trailingByteValue(byte3) &lt;&lt; 6)</span>
<span class="fc" id="L210">                          | trailingByteValue(byte4);</span>
<span class="fc" id="L211">      resultArr[resultPos] = DecodeUtil.highSurrogate(codepoint);</span>
<span class="fc" id="L212">      resultArr[resultPos + 1] = DecodeUtil.lowSurrogate(codepoint);</span>
<span class="fc" id="L213">    }</span>

    /**
     * Returns whether the byte is not a valid continuation of the form '10XXXXXX'.
     */
    private static boolean isNotTrailingByte(byte b) {
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">      return b &gt; (byte) 0xBF;</span>
    }

    /**
     * Returns the actual value of the trailing byte (removes the prefix '10') for composition.
     */
    private static int trailingByteValue(byte b) {
<span class="fc" id="L226">      return b &amp; 0x3F;</span>
    }

    private static char highSurrogate(int codePoint) {
<span class="fc" id="L230">      return (char) ((MIN_HIGH_SURROGATE - (MIN_SUPPLEMENTARY_CODE_POINT &gt;&gt;&gt; 10))</span>
                         + (codePoint &gt;&gt;&gt; 10));
    }

    private static char lowSurrogate(int codePoint) {
<span class="fc" id="L235">      return (char) (MIN_LOW_SURROGATE + (codePoint &amp; 0x3ff));</span>
    }
  }

  // These UTF-8 handling methods are copied from Guava's Utf8Unsafe class with a modification to throw
  // a protocol buffer local exception. This exception is then caught in CodedOutputStream so it can
  // fallback to more lenient behavior.
  static class UnpairedSurrogateException extends IllegalArgumentException {
    UnpairedSurrogateException(int index, int length) {
<span class="nc" id="L244">      super(&quot;Unpaired surrogate at index &quot; + index + &quot; of &quot; + length);</span>
<span class="nc" id="L245">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>