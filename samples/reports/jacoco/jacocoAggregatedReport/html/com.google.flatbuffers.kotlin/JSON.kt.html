<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JSON.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">flatbuffers</a> &gt; <a href="index.source.html" class="el_package">com.google.flatbuffers.kotlin</a> &gt; <span class="el_source">JSON.kt</span></div><h1>JSON.kt</h1><pre class="source lang-java linenums">/*
 * Copyright 2021 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
@file:Suppress(&quot;NOTHING_TO_INLINE&quot;)

package com.google.flatbuffers.kotlin

import com.google.flatbuffers.kotlin.FlexBuffersBuilder.Companion.SHARE_KEYS_AND_STRINGS
import kotlin.experimental.and
import kotlin.jvm.JvmInline
import kotlin.math.pow

/**
 * Returns a minified version of this FlexBuffer as a JSON.
 */
<span class="fc" id="L28">public fun Reference.toJson(): String = ArrayReadWriteBuffer(1024).let {</span>
<span class="fc" id="L29">  toJson(it)</span>
<span class="fc" id="L30">  val data = it.data() // it.getString(0, it.writePosition)</span>
<span class="fc" id="L31">  return data.decodeToString(0, it.writePosition)</span>
}

/**
 * Returns a minified version of this FlexBuffer as a JSON.
 * @param out [ReadWriteBuffer] the JSON will be written.
 */
public fun Reference.toJson(out: ReadWriteBuffer) {
<span class="fc" id="L39">  when (type) {</span>
<span class="fc bfc" id="L40" title="All 2 branches covered.">    T_STRING -&gt; {</span>
<span class="fc" id="L41">      val start = buffer.indirect(end, parentWidth)</span>
<span class="fc" id="L42">      val size = buffer.readULong(start - byteWidth, byteWidth).toInt()</span>
<span class="fc" id="L43">      out.jsonEscape(buffer, start, size)</span>
    }
<span class="pc bpc" id="L45" title="1 of 2 branches missed.">    T_KEY -&gt; {</span>
<span class="nc" id="L46">      val start = buffer.indirect(end, parentWidth)</span>
<span class="nc" id="L47">      val end = buffer.findFirst(0.toByte(), start)</span>
<span class="nc" id="L48">      out.jsonEscape(buffer, start, end - start)</span>
    }
<span class="pc bpc" id="L50" title="1 of 2 branches missed.">    T_BLOB -&gt; {</span>
<span class="nc" id="L51">      val blob = toBlob()</span>
<span class="nc" id="L52">      out.jsonEscape(out, blob.end, blob.size)</span>
    }
<span class="fc bfc" id="L54" title="All 2 branches covered.">    T_INT -&gt; out.put(toLong().toString())</span>
<span class="pc bpc" id="L55" title="1 of 2 branches missed.">    T_UINT -&gt; out.put(toULong().toString())</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">    T_FLOAT -&gt; out.put(toDouble().toString())</span>
<span class="fc bfc" id="L57" title="All 2 branches covered.">    T_NULL -&gt; out.put(&quot;null&quot;)</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">    T_BOOL -&gt; out.put(toBoolean().toString())</span>
<span class="fc bfc" id="L59" title="All 2 branches covered.">    T_MAP -&gt; toMap().toJson(out)</span>
<span class="pc bpc" id="L60" title="1 of 8 branches missed.">    T_VECTOR, T_VECTOR_BOOL, T_VECTOR_FLOAT, T_VECTOR_INT,</span>
<span class="pc bpc" id="L61" title="3 of 6 branches missed.">    T_VECTOR_UINT, T_VECTOR_KEY, T_VECTOR_STRING_DEPRECATED -&gt; toVector().toJson(out)</span>
<span class="nc" id="L62">    else -&gt; error(&quot;Unable to convert type ${type.typeToString()} to JSON&quot;)</span>
  }
<span class="fc" id="L64">}</span>

/**
 * Returns a minified version of this FlexBuffer as a JSON.
 */
<span class="nc" id="L69">public fun Map.toJson(): String = ArrayReadWriteBuffer(1024).let { toJson(it); it.toString() }</span>

/**
 * Returns a minified version of this FlexBuffer as a JSON.
 * @param out [ReadWriteBuffer] the JSON will be written.
 */
public fun Map.toJson(out: ReadWriteBuffer) {
<span class="fc" id="L76">  out.put('{'.code.toByte())</span>
  // key values pairs
<span class="fc bfc" id="L78" title="All 2 branches covered.">  for (i in 0 until size) {</span>
<span class="fc" id="L79">    val key = keyAt(i)</span>
<span class="fc" id="L80">    out.jsonEscape(buffer, key.start, key.sizeInBytes)</span>
<span class="fc" id="L81">    out.put(':'.code.toByte())</span>
<span class="fc" id="L82">    get(i).toJson(out)</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">    if (i != size - 1) {</span>
<span class="fc" id="L84">      out.put(','.code.toByte())</span>
    }
  }
  // close bracket
<span class="fc" id="L88">  out.put('}'.code.toByte())</span>
<span class="fc" id="L89">}</span>

/**
 * Returns a minified version of this FlexBuffer as a JSON.
 */
<span class="nc" id="L94">public fun Vector.toJson(): String = ArrayReadWriteBuffer(1024).let { toJson(it); it.toString() }</span>

/**
 * Returns a minified version of this FlexBuffer as a JSON.
 * @param out that the JSON is being concatenated.
 */
public fun Vector.toJson(out: ReadWriteBuffer) {
<span class="fc" id="L101">  out.put('['.code.toByte())</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">  for (i in 0 until size) {</span>
<span class="fc" id="L103">    get(i).toJson(out)</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">    if (i != size - 1) {</span>
<span class="fc" id="L105">      out.put(','.code.toByte())</span>
    }
  }
<span class="fc" id="L108">  out.put(']'.code.toByte())</span>
<span class="fc" id="L109">}</span>

/**
 * JSONParser class is used to parse a JSON as FlexBuffers. Calling [JSONParser.parse] fills [output]
 * and returns a [Reference] ready to be used.
 */
<span class="pc" id="L115">public class JSONParser(public var output: FlexBuffersBuilder = FlexBuffersBuilder(1024, SHARE_KEYS_AND_STRINGS)) {</span>
  private var readPos = 0
<span class="fc" id="L117">  private var scopes = ScopeStack()</span>

  /**
   * Parse a json as [String] and returns a [Reference] to a FlexBuffer.
   */
<span class="fc" id="L122">  public fun parse(data: String): Reference = parse(ArrayReadBuffer(data.encodeToByteArray()))</span>

  /**
   * Parse a json as [ByteArray] and returns a [Reference] to a FlexBuffer.
   */
<span class="nc" id="L127">  public fun parse(data: ByteArray): Reference = parse(ArrayReadBuffer(data))</span>

  /**
   * Parse a json as [ReadBuffer] and returns a [Reference] to a FlexBuffer.
   */
  public fun parse(data: ReadBuffer): Reference {
<span class="fc" id="L133">    reset()</span>
<span class="fc" id="L134">    parseValue(data, nextToken(data), null)</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">    if (readPos &lt; data.limit) {</span>
<span class="fc" id="L136">      val tok = skipWhitespace(data)</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">      if (tok != CHAR_EOF) {</span>
<span class="fc" id="L138">        makeError(data, &quot;Extraneous characters after parse has finished&quot;, tok)</span>
      }
    }
<span class="fc" id="L141">    output.finish()</span>
<span class="fc" id="L142">    return getRoot(output.buffer)</span>
  }

<span class="nc" id="L145">  private fun parseValue(data: ReadBuffer, token: Token, key: String? = null): FlexBufferType {</span>
<span class="fc" id="L146">    return when (token) {</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">      TOK_BEGIN_OBJECT -&gt; parseObject(data, key)</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">      TOK_BEGIN_ARRAY -&gt; parseArray(data, key)</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">      TOK_TRUE -&gt; T_BOOL.also { output[key] = true }</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">      TOK_FALSE -&gt; T_BOOL.also { output[key] = false }</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">      TOK_NULL -&gt; T_NULL.also { output.putNull(key) }</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">      TOK_BEGIN_QUOTE -&gt; parseString(data, key)</span>
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">      TOK_NUMBER -&gt; parseNumber(data, data.data(), key)</span>
<span class="nc" id="L154">      else -&gt; makeError(data, &quot;Unexpected Character while parsing&quot;, 'x'.code.toByte())</span>
    }
  }

<span class="nc" id="L158">  private fun parseObject(data: ReadBuffer, key: String? = null): FlexBufferType {</span>
<span class="fc" id="L159">    this.scopes.push(SCOPE_OBJ_EMPTY)</span>

<span class="fc" id="L161">    val fPos = output.startMap()</span>
<span class="fc" id="L162">    val limit = data.limit</span>
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">    while (readPos &lt;= limit) {</span>
<span class="fc" id="L164">      when (val tok = nextToken(data)) {</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">        TOK_END_OBJECT -&gt; {</span>
<span class="fc" id="L166">          this.scopes.pop()</span>
<span class="fc" id="L167">          output.endMap(fPos, key); return T_MAP</span>
        }
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">        TOK_BEGIN_QUOTE -&gt; {</span>
<span class="fc" id="L170">          val childKey = readString(data)</span>
<span class="fc" id="L171">          parseValue(data, nextToken(data), childKey)</span>
        }
<span class="nc" id="L173">        else -&gt; makeError(data, &quot;Expecting start of object key&quot;, tok)</span>
      }
    }
<span class="nc" id="L176">    makeError(data, &quot;Unable to parse the object&quot;, &quot;x&quot;.toByte())</span>
  }

<span class="nc" id="L179">  private fun parseArray(data: ReadBuffer, key: String? = null): FlexBufferType {</span>
<span class="fc" id="L180">    this.scopes.push(SCOPE_ARRAY_EMPTY)</span>
<span class="fc" id="L181">    val fPos = output.startVector()</span>
<span class="fc" id="L182">    var elementType = T_INVALID</span>
<span class="fc" id="L183">    var multiType = false</span>
<span class="fc" id="L184">    val limit = data.limit</span>

<span class="pc bpc" id="L186" title="1 of 2 branches missed.">    while (readPos &lt;= limit) {</span>
<span class="fc" id="L187">      when (val tok = nextToken(data)) {</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">        TOK_END_ARRAY -&gt; {</span>
<span class="fc" id="L189">          this.scopes.pop()</span>
<span class="fc bfc" id="L190" title="All 4 branches covered.">          return if (!multiType &amp;&amp; elementType.isScalar()) {</span>
<span class="fc" id="L191">            output.endTypedVector(fPos, key)</span>
<span class="fc" id="L192">            elementType.toElementTypedVector()</span>
          } else {
<span class="fc" id="L194">            output.endVector(key, fPos)</span>
<span class="fc" id="L195">            T_VECTOR</span>
          }
        }

        else -&gt; {
<span class="fc" id="L200">          val newType = parseValue(data, tok, null)</span>

<span class="fc bfc" id="L202" title="All 2 branches covered.">          if (elementType == T_INVALID) {</span>
<span class="fc" id="L203">            elementType = newType</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">          } else if (newType != elementType) {</span>
<span class="fc" id="L205">            multiType = true</span>
          }
        }
      }
    }
<span class="nc" id="L210">    makeError(data, &quot;Unable to parse the array&quot;)</span>
  }

  private fun parseNumber(data: ReadBuffer, array: ByteArray, key: String?): FlexBufferType {
<span class="fc" id="L214">    val ary = array</span>
<span class="fc" id="L215">    var cursor = readPos</span>
<span class="fc" id="L216">    var c = data[readPos++]</span>
<span class="fc" id="L217">    var useDouble = false</span>
<span class="fc" id="L218">    val limit = ary.size</span>
<span class="fc" id="L219">    var sign = 1</span>
    var double: Double
<span class="fc" id="L221">    var long = 0L</span>
<span class="fc" id="L222">    var digits = 0</span>

<span class="fc bfc" id="L224" title="All 2 branches covered.">    if (c == CHAR_MINUS) {</span>
<span class="fc" id="L225">      cursor++</span>
<span class="fc" id="L226">      checkEOF(data, cursor)</span>
<span class="fc" id="L227">      c = ary[cursor]</span>
<span class="fc" id="L228">      sign = -1</span>
    }

    // peek first byte
<span class="fc" id="L232">    when (c) {</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">      CHAR_0 -&gt; {</span>
<span class="fc" id="L234">        cursor++</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">        if (cursor != limit) {</span>
<span class="fc" id="L236">          c = ary[cursor]</span>
        }
      }
<span class="pc bpc" id="L239" title="3 of 6 branches missed.">      !in CHAR_0..CHAR_9 -&gt; makeError(data, &quot;Invalid Number&quot;, c)</span>
      else -&gt; {
        do {
<span class="fc" id="L242">          val digit = c - CHAR_0</span>
          // double = 10.0 * double + digit
<span class="fc" id="L244">          long = 10 * long + digit</span>
<span class="fc" id="L245">          digits++</span>
<span class="fc" id="L246">          cursor++</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">          if (cursor == limit) break</span>
<span class="fc" id="L248">          c = ary[cursor]</span>
<span class="fc bfc" id="L249" title="All 6 branches covered.">        } while (c in CHAR_0..CHAR_9)</span>
      }
    }

<span class="fc" id="L253">    var exponent = 0</span>
    // If we find '.' we need to convert to double
<span class="fc bfc" id="L255" title="All 2 branches covered.">    if (c == CHAR_DOT) {</span>
<span class="fc" id="L256">      useDouble = true</span>
<span class="fc" id="L257">      checkEOF(data, cursor)</span>
<span class="fc" id="L258">      c = ary[++cursor]</span>
<span class="pc bpc" id="L259" title="2 of 4 branches missed.">      if (c &lt; CHAR_0 || c &gt; CHAR_9) {</span>
<span class="nc" id="L260">        makeError(data, &quot;Invalid Number&quot;, c)</span>
      }
      do {
        // double = double * 10 + (tok - CHAR_0)
<span class="fc" id="L264">        long = 10 * long + (c - CHAR_0)</span>
<span class="fc" id="L265">        digits++</span>
<span class="fc" id="L266">        --exponent</span>
<span class="fc" id="L267">        cursor++</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">        if (cursor == limit) break</span>
<span class="fc" id="L269">        c = ary[cursor]</span>
<span class="fc bfc" id="L270" title="All 6 branches covered.">      } while (c in CHAR_0..CHAR_9)</span>
    }

    // If we find 'e' we need to convert to double
<span class="fc bfc" id="L274" title="All 4 branches covered.">    if (c == CHAR_e || c == CHAR_E) {</span>
<span class="fc" id="L275">      useDouble = true</span>
<span class="fc" id="L276">      ++cursor</span>
<span class="fc" id="L277">      checkEOF(data, cursor)</span>
<span class="fc" id="L278">      c = ary[cursor]</span>
<span class="fc" id="L279">      var negativeExponent = false</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">      if (c == CHAR_MINUS) {</span>
<span class="fc" id="L281">        ++cursor</span>
<span class="fc" id="L282">        checkEOF(data, cursor)</span>
<span class="fc" id="L283">        negativeExponent = true</span>
<span class="fc" id="L284">        c = ary[cursor]</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">      } else if (c == CHAR_PLUS) {</span>
<span class="fc" id="L286">        ++cursor</span>
<span class="fc" id="L287">        checkEOF(data, cursor)</span>
<span class="fc" id="L288">        c = ary[cursor]</span>
      }
<span class="fc bfc" id="L290" title="All 4 branches covered.">      if (c &lt; CHAR_0 || c &gt; CHAR_9) {</span>
<span class="fc" id="L291">        makeError(data, &quot;Missing exponent&quot;, c)</span>
      }
<span class="fc" id="L293">      var exp = 0</span>
      do {
<span class="fc" id="L295">        val digit = c - CHAR_0</span>
<span class="fc" id="L296">        exp = 10 * exp + digit</span>
<span class="fc" id="L297">        ++cursor</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">        if (cursor == limit) break</span>
<span class="fc" id="L299">        c = ary[cursor]</span>
<span class="fc bfc" id="L300" title="All 6 branches covered.">      } while (c in CHAR_0..CHAR_9)</span>

<span class="fc bfc" id="L302" title="All 2 branches covered.">      exponent += if (negativeExponent) -exp else exp</span>
    }

<span class="pc bpc" id="L305" title="1 of 6 branches missed.">    if (digits &gt; 17 || exponent &lt; -19 || exponent &gt; 19) {</span>
      // if the float number is not simple enough
      // we use language's Double parsing, which is slower but
      // produce more expected results for extreme numbers.
<span class="fc" id="L309">      val firstPos = readPos - 1</span>
<span class="fc" id="L310">      val str = data.getString(firstPos, cursor - firstPos)</span>
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">      if (useDouble) {</span>
<span class="fc" id="L312">        double = str.toDouble()</span>
<span class="fc" id="L313">        output[key] = double</span>
      } else {
<span class="nc" id="L315">        long = str.toLong()</span>
<span class="nc" id="L316">        output[key] = long</span>
      }
    } else {
      // this happens on single numbers outside any object
      // or array
<span class="pc bpc" id="L321" title="1 of 4 branches missed.">      if (useDouble || exponent != 0) {</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">        double = if (long == 0L) 0.0 else long.toDouble() * 10.0.pow(exponent)</span>
<span class="fc" id="L323">        double *= sign</span>
<span class="fc" id="L324">        output[key] = double</span>
      } else {
<span class="fc" id="L326">        long *= sign</span>
<span class="fc" id="L327">        output[key] = long</span>
      }
    }
<span class="fc" id="L330">    readPos = cursor</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">    return if (useDouble) T_FLOAT else T_INT</span>
  }

  private fun parseString(data: ReadBuffer, key: String?): FlexBufferType {
<span class="fc" id="L335">    output[key] = readString(data)</span>
<span class="fc" id="L336">    return T_STRING</span>
  }

  private fun readString(data: ReadBuffer): String {
<span class="fc" id="L340">    val limit = data.limit</span>
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">    if (data is ArrayReadBuffer) {</span>
<span class="fc" id="L342">      val ary = data.data()</span>
      // enables range check elimination
<span class="fc" id="L344">      return readString(data, limit) { ary[it] }</span>
    }
<span class="nc" id="L346">    return readString(data, limit) { data[it] }</span>
  }

  private inline fun readString(data: ReadBuffer, limit: Int, crossinline fetch: (Int) -&gt; Byte): String {
<span class="nc" id="L350">    var cursorPos = readPos</span>
<span class="nc" id="L351">    var foundEscape = false</span>
<span class="nc" id="L352">    var currentChar: Byte = 0</span>
    // we loop over every 4 bytes until find any non-plain char
<span class="nc bnc" id="L354" title="All 2 branches missed.">    while (limit - cursorPos &gt;= 4) {</span>
<span class="nc" id="L355">      currentChar = fetch(cursorPos)</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">      if (!isPlainStringChar(currentChar)) {</span>
<span class="nc" id="L357">        foundEscape = true</span>
<span class="nc" id="L358">        break</span>
      }
<span class="nc" id="L360">      currentChar = fetch(cursorPos + 1)</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">      if (!isPlainStringChar(currentChar)) {</span>
<span class="nc" id="L362">        cursorPos += 1</span>
<span class="nc" id="L363">        foundEscape = true</span>
<span class="nc" id="L364">        break</span>
      }
<span class="nc" id="L366">      currentChar = fetch(cursorPos + 2)</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">      if (!isPlainStringChar(currentChar)) {</span>
<span class="nc" id="L368">        cursorPos += 2</span>
<span class="nc" id="L369">        foundEscape = true</span>
<span class="nc" id="L370">        break</span>
      }
<span class="nc" id="L372">      currentChar = fetch(cursorPos + 3)</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">      if (!isPlainStringChar(currentChar)) {</span>
<span class="nc" id="L374">        cursorPos += 3</span>
<span class="nc" id="L375">        foundEscape = true</span>
<span class="nc" id="L376">        break</span>
      }
<span class="nc" id="L378">      cursorPos += 4</span>
    }
<span class="nc bnc" id="L380" title="All 2 branches missed.">    if (!foundEscape) {</span>
      // if non-plain string char is not found we loop over
      // the remaining bytes
<span class="nc" id="L383">      while (true) {</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">        if (cursorPos &gt;= limit) {</span>
<span class="nc" id="L385">          error(&quot;Unexpected end of string&quot;)</span>
        }
<span class="nc" id="L387">        currentChar = fetch(cursorPos)</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">        if (!isPlainStringChar(currentChar)) {</span>
<span class="nc" id="L389">          break</span>
        }
<span class="nc" id="L391">        ++cursorPos</span>
      }
    }
<span class="nc bnc" id="L394" title="All 2 branches missed.">    if (currentChar == CHAR_DOUBLE_QUOTE) {</span>
<span class="nc" id="L395">      val str = data.getString(readPos, cursorPos - readPos)</span>
<span class="nc" id="L396">      readPos = cursorPos + 1</span>
<span class="nc" id="L397">      return str</span>
    }
<span class="nc bnc" id="L399" title="All 6 branches missed.">    if (currentChar in 0..0x1f) {</span>
<span class="nc" id="L400">      error(&quot;Illegal Codepoint&quot;)</span>
    } else {
      // backslash or &gt;0x7f
<span class="nc" id="L403">      return readStringSlow(data, currentChar, cursorPos)</span>
    }
  }

  private fun readStringSlow(data: ReadBuffer, first: Byte, lastPos: Int): String {
<span class="fc" id="L408">    var cursorPos = lastPos</span>

<span class="fc" id="L410">    var endOfString = lastPos</span>
<span class="fc" id="L411">    while (true) {</span>
<span class="fc" id="L412">      val pos = data.findFirst(CHAR_DOUBLE_QUOTE, endOfString)</span>
<span class="fc" id="L413">      when {</span>
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">        pos == -1 -&gt; makeError(data, &quot;Unexpected EOF, missing end of string '\&quot;'&quot;, first)</span>
<span class="fc bfc" id="L415" title="All 4 branches covered.">        data[pos - 1] == CHAR_BACKSLASH &amp;&amp; data[pos - 2] != CHAR_BACKSLASH -&gt; {</span>
          // here we are checking for double quotes preceded by backslash. eg \&quot;
          // we have to look past pos -2 to make sure that the backlash is not
          // part of a previous escape, eg &quot;\\&quot;
<span class="fc" id="L419">          endOfString = pos + 1</span>
        }
        else -&gt; {
<span class="fc" id="L422">          endOfString = pos; break</span>
        }
      }
    }
    // copy everything before the escape
<span class="fc" id="L427">    val builder = StringBuilder(data.getString(readPos, lastPos - readPos))</span>
<span class="fc" id="L428">    while (true) {</span>
<span class="fc" id="L429">      when (val pos = data.findFirst(CHAR_BACKSLASH, cursorPos, endOfString)) {</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">        -1 -&gt; {</span>
<span class="fc" id="L431">          val doubleQuotePos = data.findFirst(CHAR_DOUBLE_QUOTE, cursorPos)</span>
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">          if (doubleQuotePos == -1) makeError(data, &quot;Reached EOF before enclosing string&quot;, first)</span>
<span class="fc" id="L433">          val rest = data.getString(cursorPos, doubleQuotePos - cursorPos)</span>
<span class="fc" id="L434">          builder.append(rest)</span>
<span class="fc" id="L435">          readPos = doubleQuotePos + 1</span>
<span class="fc" id="L436">          return builder.toString()</span>
        }

        else -&gt; {
          // we write everything up to \
<span class="fc" id="L441">          builder.append(data.getString(cursorPos, pos - cursorPos))</span>
<span class="fc" id="L442">          val c = data[pos + 1]</span>
<span class="fc" id="L443">          builder.append(readEscapedChar(data, c, pos))</span>
<span class="fc bfc" id="L444" title="All 2 branches covered.">          cursorPos = pos + if (c == CHAR_u) 6 else 2</span>
        }
      }
    }
  }

  private inline fun isPlainStringChar(c: Byte): Boolean {
<span class="nc" id="L451">    val flags = parseFlags</span>
    // return c in 0x20..0x7f &amp;&amp; c != 0x22.toByte() &amp;&amp; c != 0x5c.toByte()
<span class="nc bnc" id="L453" title="All 2 branches missed.">    return (flags[c.toInt() and 0xFF] and 1) != 0.toByte()</span>
  }

  private inline fun isWhitespace(c: Byte): Boolean {
<span class="nc" id="L457">    val flags = parseFlags</span>
    // return c == '\r'.toByte() || c == '\n'.toByte() || c == '\t'.toByte() || c == ' '.toByte()
<span class="nc bnc" id="L459" title="All 2 branches missed.">    return (flags[c.toInt() and 0xFF] and 2) != 0.toByte()</span>
  }

  private fun reset() {
<span class="fc" id="L463">    readPos = 0</span>
<span class="fc" id="L464">    output.clear()</span>
<span class="fc" id="L465">    scopes.reset()</span>
<span class="fc" id="L466">  }</span>

  private fun nextToken(data: ReadBuffer): Token {
<span class="fc" id="L469">    val scope = this.scopes.last</span>

<span class="fc" id="L471">    when (scope) {</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">      SCOPE_ARRAY_EMPTY -&gt; this.scopes.last = SCOPE_ARRAY_FILLED</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">      SCOPE_ARRAY_FILLED -&gt; {</span>
<span class="fc" id="L474">        when (val c = skipWhitespace(data)) {</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">          CHAR_CLOSE_ARRAY -&gt; return TOK_END_ARRAY</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">          CHAR_COMMA -&gt; Unit</span>
<span class="fc" id="L477">          else -&gt; makeError(data, &quot;Unfinished Array&quot;, c)</span>
        }
      }
<span class="fc bfc" id="L480" title="All 4 branches covered.">      SCOPE_OBJ_EMPTY, SCOPE_OBJ_FILLED -&gt; {</span>
<span class="fc" id="L481">        this.scopes.last = SCOPE_OBJ_KEY</span>
        // Look for a comma before the next element.
<span class="fc bfc" id="L483" title="All 2 branches covered.">        if (scope == SCOPE_OBJ_FILLED) {</span>
<span class="fc" id="L484">          when (val c = skipWhitespace(data)) {</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">            CHAR_CLOSE_OBJECT -&gt; return TOK_END_OBJECT</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">            CHAR_COMMA -&gt; Unit</span>
<span class="fc" id="L487">            else -&gt; makeError(data, &quot;Unfinished Object&quot;, c)</span>
          }
        }
<span class="fc" id="L490">        return when (val c = skipWhitespace(data)) {</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">          CHAR_DOUBLE_QUOTE -&gt; TOK_BEGIN_QUOTE</span>
<span class="fc bfc" id="L492" title="All 4 branches covered.">          CHAR_CLOSE_OBJECT -&gt; if (scope != SCOPE_OBJ_FILLED) {</span>
<span class="fc" id="L493">            TOK_END_OBJECT</span>
          } else {
<span class="fc" id="L495">            makeError(data, &quot;Expected Key&quot;, c)</span>
          }
          else -&gt; {
<span class="fc" id="L498">            makeError(data, &quot;Expected Key/Value&quot;, c)</span>
          }
        }
      }
<span class="fc bfc" id="L502" title="All 2 branches covered.">      SCOPE_OBJ_KEY -&gt; {</span>
<span class="fc" id="L503">        this.scopes.last = SCOPE_OBJ_FILLED</span>
<span class="fc" id="L504">        when (val c = skipWhitespace(data)) {</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">          CHAR_COLON -&gt; Unit</span>
<span class="fc" id="L506">          else -&gt; makeError(data, &quot;Expect ${CHAR_COLON.print()}&quot;, c)</span>
        }
      }
<span class="pc bpc" id="L509" title="1 of 2 branches missed.">      SCOPE_DOC_EMPTY -&gt; this.scopes.last = SCOPE_DOC_FILLED</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">      SCOPE_DOC_FILLED -&gt; {</span>
<span class="nc" id="L511">        val c = skipWhitespace(data)</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">        if (c != CHAR_EOF)</span>
<span class="nc" id="L513">          makeError(data, &quot;Root object already finished&quot;, c)</span>
<span class="nc" id="L514">        return TOK_EOF</span>
      }
    }

<span class="fc" id="L518">    val c = skipWhitespace(data)</span>
<span class="fc" id="L519">    when (c) {</span>
<span class="fc bfc" id="L520" title="All 4 branches covered.">      CHAR_CLOSE_ARRAY -&gt; if (scope == SCOPE_ARRAY_EMPTY) return TOK_END_ARRAY</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">      CHAR_COLON -&gt; makeError(data, &quot;Unexpected character&quot;, c)</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">      CHAR_DOUBLE_QUOTE -&gt; return TOK_BEGIN_QUOTE</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">      CHAR_OPEN_ARRAY -&gt; return TOK_BEGIN_ARRAY</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">      CHAR_OPEN_OBJECT -&gt; return TOK_BEGIN_OBJECT</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">      CHAR_t -&gt; {</span>
<span class="fc" id="L526">        checkEOF(data, readPos + 2)</span>
        // 0x65757274 is equivalent to ['t', 'r', 'u', 'e' ] as a 4 byte Int
<span class="fc bfc" id="L528" title="All 2 branches covered.">        if (data.getInt(readPos - 1) != 0x65757274) {</span>
<span class="fc" id="L529">          makeError(data, &quot;Expecting keyword \&quot;true\&quot;&quot;, c)</span>
        }
<span class="fc" id="L531">        readPos += 3</span>
<span class="fc" id="L532">        return TOK_TRUE</span>
      }
<span class="fc bfc" id="L534" title="All 2 branches covered.">      CHAR_n -&gt; {</span>
<span class="fc" id="L535">        checkEOF(data, readPos + 2)</span>
        // 0x6c6c756e  is equivalent to ['n', 'u', 'l', 'l' ] as a 4 byte Int
<span class="pc bpc" id="L537" title="1 of 2 branches missed.">        if (data.getInt(readPos - 1) != 0x6c6c756e) {</span>
<span class="nc" id="L538">          makeError(data, &quot;Expecting keyword \&quot;null\&quot;&quot;, c)</span>
        }
<span class="fc" id="L540">        readPos += 3</span>
<span class="fc" id="L541">        return TOK_NULL</span>
      }
<span class="fc bfc" id="L543" title="All 2 branches covered.">      CHAR_f -&gt; {</span>
<span class="fc" id="L544">        checkEOF(data, readPos + 3)</span>
        // 0x65736c61 is equivalent to ['a', 'l', 's', 'e' ] as a 4 byte Int
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">        if (data.getInt(readPos) != 0x65736c61) {</span>
<span class="nc" id="L547">          makeError(data, &quot;Expecting keyword \&quot;false\&quot;&quot;, c)</span>
        }
<span class="fc" id="L549">        readPos += 4</span>
<span class="fc" id="L550">        return TOK_FALSE</span>
      }
<span class="fc bfc" id="L552" title="All 22 branches covered.">      CHAR_0, CHAR_1, CHAR_2, CHAR_3, CHAR_4, CHAR_5,</span>
<span class="pc bpc" id="L553" title="1 of 20 branches missed.">      CHAR_6, CHAR_7, CHAR_8, CHAR_9, CHAR_MINUS -&gt; return TOK_NUMBER.also {</span>
<span class="fc" id="L554">        readPos-- // rewind one position so we don't lose first digit</span>
<span class="fc" id="L555">      }</span>
    }
<span class="fc" id="L557">    makeError(data, &quot;Expecting element&quot;, c)</span>
  }

  // keeps increasing [readPos] until finds a non-whitespace byte
  private inline fun skipWhitespace(data: ReadBuffer): Byte {
<span class="nc" id="L562">    val limit = data.limit</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">    if (data is ArrayReadBuffer) {</span>
      // enables range check elimination
<span class="nc" id="L565">      val ary = data.data()</span>
<span class="nc" id="L566">      return skipWhitespace(limit) { ary[it] }</span>
    }
<span class="nc" id="L568">    return skipWhitespace(limit) { data[it] }</span>
  }

  private inline fun skipWhitespace(limit: Int, crossinline fetch: (Int) -&gt; Byte): Byte {
<span class="nc" id="L572">    var pos = readPos</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">    while (pos &lt; limit) {</span>
<span class="nc" id="L574">      val d = fetch(pos++)</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">      if (!isWhitespace(d)) {</span>
<span class="nc" id="L576">        readPos = pos</span>
<span class="nc" id="L577">        return d</span>
      }
    }
<span class="nc" id="L580">    readPos = limit</span>
<span class="nc" id="L581">    return CHAR_EOF</span>
  }

  // byte1 is expected to be first char before `\`
  private fun readEscapedChar(data: ReadBuffer, byte1: Byte, cursorPos: Int): Char {
<span class="fc" id="L586">    return when (byte1) {</span>
<span class="fc bfc" id="L587" title="All 2 branches covered.">      CHAR_u -&gt; {</span>
<span class="fc" id="L588">        checkEOF(data, cursorPos + 1 + 4)</span>
<span class="fc" id="L589">        var result: Char = 0.toChar()</span>
<span class="fc" id="L590">        var i = cursorPos + 2 // cursorPos is on '\\', cursorPos + 1 is 'u'</span>
<span class="fc" id="L591">        val end = i + 4</span>
<span class="fc bfc" id="L592" title="All 2 branches covered.">        while (i &lt; end) {</span>
<span class="fc" id="L593">          val part: Byte = data[i]</span>
<span class="fc" id="L594">          result = (result.code shl 4).toChar()</span>
<span class="fc" id="L595">          result += when (part) {</span>
<span class="pc bpc" id="L596" title="1 of 6 branches missed.">            in CHAR_0..CHAR_9 -&gt; part - CHAR_0</span>
<span class="pc bpc" id="L597" title="1 of 6 branches missed.">            in CHAR_a..CHAR_f -&gt; part - CHAR_a + 10</span>
<span class="pc bpc" id="L598" title="3 of 6 branches missed.">            in CHAR_A..CHAR_F -&gt; part - CHAR_A + 10</span>
<span class="nc" id="L599">            else -&gt; makeError(data, &quot;Invalid utf8 escaped character&quot;, -1)</span>
          }
<span class="fc" id="L601">          i++</span>
        }
<span class="fc" id="L603">        result</span>
      }
<span class="fc bfc" id="L605" title="All 2 branches covered.">      CHAR_b -&gt; '\b'</span>
<span class="fc bfc" id="L606" title="All 2 branches covered.">      CHAR_t -&gt; '\t'</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">      CHAR_r -&gt; '\r'</span>
<span class="fc bfc" id="L608" title="All 2 branches covered.">      CHAR_n -&gt; '\n'</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">      CHAR_f -&gt; 12.toChar() // '\f'</span>
<span class="fc bfc" id="L610" title="All 10 branches covered.">      CHAR_DOUBLE_QUOTE, CHAR_BACKSLASH, CHAR_FORWARDSLASH -&gt; byte1.toInt().toChar()</span>
<span class="fc" id="L611">      else -&gt; makeError(data, &quot;Invalid escape sequence.&quot;, byte1)</span>
    }
  }

<span class="fc" id="L615">  private fun Byte.print(): String = when (this) {</span>
<span class="pc bpc" id="L616" title="1 of 6 branches missed.">    in 0x21..0x7E -&gt; &quot;'${this.toInt().toChar()}'&quot; // visible ascii chars</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">    CHAR_EOF -&gt; &quot;EOF&quot;</span>
<span class="fc" id="L618">    else -&gt; &quot;'0x${this.toString(16)}'&quot;</span>
<span class="fc" id="L619">  }</span>

<span class="nc" id="L621">  private inline fun makeError(data: ReadBuffer, msg: String, tok: Byte? = null): Nothing {</span>
<span class="nc" id="L622">    val (line, column) = calculateErrorPosition(data, readPos)</span>
<span class="nc bnc" id="L623" title="All 4 branches missed.">    if (tok != null) {</span>
<span class="nc" id="L624">      error(&quot;Error At ($line, $column): $msg, got ${tok.print()}&quot;)</span>
    } else {
<span class="nc" id="L626">      error(&quot;Error At ($line, $column): $msg&quot;)</span>
    }
  }

  private inline fun makeError(data: ReadBuffer, msg: String, tok: Token): Nothing {
<span class="nc" id="L631">    val (line, column) = calculateErrorPosition(data, readPos)</span>
<span class="nc" id="L632">    error(&quot;Error At ($line, $column): $msg, got ${tok.print()}&quot;)</span>
  }

  private inline fun checkEOF(data: ReadBuffer, pos: Int) {
<span class="nc bnc" id="L636" title="All 2 branches missed.">    if (pos &gt;= data.limit)</span>
<span class="nc" id="L637">      makeError(data, &quot;Unexpected end of file&quot;, -1)</span>
<span class="nc" id="L638">  }</span>

  private fun calculateErrorPosition(data: ReadBuffer, endPos: Int): Pair&lt;Int, Int&gt; {
<span class="fc" id="L641">    var line = 1</span>
<span class="fc" id="L642">    var column = 1</span>
<span class="fc" id="L643">    var current = 0</span>
<span class="fc bfc" id="L644" title="All 2 branches covered.">    while (current &lt; endPos - 1) {</span>
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">      if (data[current++] == CHAR_NEWLINE) {</span>
<span class="nc" id="L646">        ++line</span>
<span class="nc" id="L647">        column = 1</span>
      } else {
<span class="fc" id="L649">        ++column</span>
      }
    }
<span class="fc" id="L652">    return Pair(line, column)</span>
  }
<span class="fc" id="L654">}</span>

<span class="nc" id="L656">internal inline fun Int.toPaddedHex(): String = &quot;\\u${this.toString(16).padStart(4, '0')}&quot;</span>

private inline fun ReadWriteBuffer.jsonEscape(data: ReadBuffer, start: Int, size: Int) {
<span class="nc" id="L659">  val replacements = JSON_ESCAPE_CHARS</span>
<span class="nc" id="L660">  put(CHAR_DOUBLE_QUOTE)</span>
<span class="nc" id="L661">  var last = start</span>
<span class="nc" id="L662">  val length: Int = size</span>
<span class="nc" id="L663">  val ary = data.data()</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">  for (i in start until start + length) {</span>
<span class="nc" id="L665">    val c = ary[i].toUByte()</span>
    var replacement: ByteArray?
<span class="nc bnc" id="L667" title="All 2 branches missed.">    if (c.toInt() &lt; 128) {</span>
<span class="nc" id="L668">      replacement = replacements[c.toInt()]</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">      if (replacement == null) {</span>
<span class="nc" id="L670">        continue</span>
      }
    } else {
<span class="nc" id="L673">      continue</span>
    }
<span class="nc bnc" id="L675" title="All 2 branches missed.">    if (last &lt; i) {</span>
<span class="nc" id="L676">      put(ary, last, i - last)</span>
    }
<span class="nc" id="L678">    put(replacement, 0, replacement.size)</span>
<span class="nc" id="L679">    last = i + 1</span>
  }
<span class="nc bnc" id="L681" title="All 2 branches missed.">  if (last &lt; (last + length)) {</span>
<span class="nc" id="L682">    put(ary, last, (start + length) - last)</span>
  }
<span class="nc" id="L684">  put(CHAR_DOUBLE_QUOTE)</span>
<span class="nc" id="L685">}</span>

// Following escape strategy defined in RFC7159.
<span class="fc" id="L688">private val JSON_ESCAPE_CHARS: Array&lt;ByteArray?&gt; = arrayOfNulls&lt;ByteArray&gt;(128).apply {</span>
<span class="fc" id="L689">  this['\n'.code] = &quot;\\n&quot;.encodeToByteArray()</span>
<span class="fc" id="L690">  this['\t'.code] = &quot;\\t&quot;.encodeToByteArray()</span>
<span class="fc" id="L691">  this['\r'.code] = &quot;\\r&quot;.encodeToByteArray()</span>
<span class="fc" id="L692">  this['\b'.code] = &quot;\\b&quot;.encodeToByteArray()</span>
<span class="fc" id="L693">  this[0x0c] = &quot;\\f&quot;.encodeToByteArray()</span>
<span class="fc" id="L694">  this['&quot;'.code] = &quot;\\\&quot;&quot;.encodeToByteArray()</span>
<span class="fc" id="L695">  this['\\'.code] = &quot;\\\\&quot;.encodeToByteArray()</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">  for (i in 0..0x1f) {</span>
<span class="fc" id="L697">    this[i] = &quot;\\u${i.toPaddedHex()}&quot;.encodeToByteArray()</span>
  }
<span class="fc" id="L699">}</span>

// Scope is used to define current space that the scanner is operating.
@JvmInline
<span class="nc" id="L703">private value class Scope(val id: Int)</span>
<span class="fc" id="L704">private val SCOPE_DOC_EMPTY = Scope(0)</span>
<span class="fc" id="L705">private val SCOPE_DOC_FILLED = Scope(1)</span>
<span class="fc" id="L706">private val SCOPE_OBJ_EMPTY = Scope(2)</span>
<span class="fc" id="L707">private val SCOPE_OBJ_KEY = Scope(3)</span>
<span class="fc" id="L708">private val SCOPE_OBJ_FILLED = Scope(4)</span>
<span class="fc" id="L709">private val SCOPE_ARRAY_EMPTY = Scope(5)</span>
<span class="fc" id="L710">private val SCOPE_ARRAY_FILLED = Scope(6)</span>

// Keeps the stack state of the scopes being scanned. Currently defined to have a
// max stack size of 22, as per tests cases defined in http://json.org/JSON_checker/
<span class="fc" id="L714">private class ScopeStack(</span>
<span class="fc bfc" id="L715" title="All 2 branches covered.">  private val ary: IntArray = IntArray(22) { SCOPE_DOC_EMPTY.id },</span>
<span class="pc" id="L716">  var lastPos: Int = 0</span>
) {
  var last: Scope
<span class="fc" id="L719">    get() = Scope(ary[lastPos])</span>
    set(x) {
<span class="fc" id="L721">      ary[lastPos] = x.id</span>
<span class="fc" id="L722">    }</span>

  fun reset() {
<span class="fc" id="L725">    lastPos = 0</span>
<span class="fc" id="L726">    ary[0] = SCOPE_DOC_EMPTY.id</span>
<span class="fc" id="L727">  }</span>

  fun pop(): Scope {
    // println(&quot;Popping: ${last.print()}&quot;)
<span class="fc" id="L731">    return Scope(ary[lastPos--])</span>
  }

  fun push(scope: Scope): Scope {
<span class="fc bfc" id="L735" title="All 2 branches covered.">    if (lastPos == ary.size - 1)</span>
<span class="fc" id="L736">      error(&quot;Too much nesting reached. Max nesting is ${ary.size} levels&quot;)</span>
    // println(&quot;PUSHING : ${scope.print()}&quot;)
<span class="fc" id="L738">    ary[++lastPos] = scope.id</span>
<span class="fc" id="L739">    return scope</span>
  }
<span class="fc" id="L741">}</span>

@JvmInline
<span class="nc" id="L744">private value class Token(val id: Int) {</span>
<span class="nc" id="L745">  fun print(): String = when (this) {</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">    TOK_EOF -&gt; &quot;TOK_EOF&quot;</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">    TOK_NONE -&gt; &quot;TOK_NONE&quot;</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">    TOK_BEGIN_OBJECT -&gt; &quot;TOK_BEGIN_OBJECT&quot;</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">    TOK_END_OBJECT -&gt; &quot;TOK_END_OBJECT&quot;</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">    TOK_BEGIN_ARRAY -&gt; &quot;TOK_BEGIN_ARRAY&quot;</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">    TOK_END_ARRAY -&gt; &quot;TOK_END_ARRAY&quot;</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">    TOK_NUMBER -&gt; &quot;TOK_NUMBER&quot;</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">    TOK_TRUE -&gt; &quot;TOK_TRUE&quot;</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">    TOK_FALSE -&gt; &quot;TOK_FALSE&quot;</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">    TOK_NULL -&gt; &quot;TOK_NULL&quot;</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">    TOK_BEGIN_QUOTE -&gt; &quot;TOK_BEGIN_QUOTE&quot;</span>
<span class="nc" id="L757">    else -&gt; this.toString()</span>
<span class="nc" id="L758">  }</span>
}

<span class="fc" id="L761">private val TOK_EOF = Token(-1)</span>
<span class="fc" id="L762">private val TOK_NONE = Token(0)</span>
<span class="fc" id="L763">private val TOK_BEGIN_OBJECT = Token(1)</span>
<span class="fc" id="L764">private val TOK_END_OBJECT = Token(2)</span>
<span class="fc" id="L765">private val TOK_BEGIN_ARRAY = Token(3)</span>
<span class="fc" id="L766">private val TOK_END_ARRAY = Token(4)</span>
<span class="fc" id="L767">private val TOK_NUMBER = Token(5)</span>
<span class="fc" id="L768">private val TOK_TRUE = Token(6)</span>
<span class="fc" id="L769">private val TOK_FALSE = Token(7)</span>
<span class="fc" id="L770">private val TOK_NULL = Token(8)</span>
<span class="fc" id="L771">private val TOK_BEGIN_QUOTE = Token(9)</span>

private const val CHAR_NEWLINE = '\n'.code.toByte()
private const val CHAR_OPEN_OBJECT = '{'.code.toByte()
private const val CHAR_COLON = ':'.code.toByte()
private const val CHAR_CLOSE_OBJECT = '}'.code.toByte()
private const val CHAR_OPEN_ARRAY = '['.code.toByte()
private const val CHAR_CLOSE_ARRAY = ']'.code.toByte()
private const val CHAR_DOUBLE_QUOTE = '&quot;'.code.toByte()
private const val CHAR_BACKSLASH = '\\'.code.toByte()
private const val CHAR_FORWARDSLASH = '/'.code.toByte()
private const val CHAR_f = 'f'.code.toByte()
private const val CHAR_a = 'a'.code.toByte()
private const val CHAR_r = 'r'.code.toByte()
private const val CHAR_t = 't'.code.toByte()
private const val CHAR_n = 'n'.code.toByte()
private const val CHAR_b = 'b'.code.toByte()
private const val CHAR_e = 'e'.code.toByte()
private const val CHAR_E = 'E'.code.toByte()
private const val CHAR_u = 'u'.code.toByte()
private const val CHAR_A = 'A'.code.toByte()
private const val CHAR_F = 'F'.code.toByte()
private const val CHAR_EOF = (-1).toByte()
private const val CHAR_COMMA = ','.code.toByte()
private const val CHAR_0 = '0'.code.toByte()
private const val CHAR_1 = '1'.code.toByte()
private const val CHAR_2 = '2'.code.toByte()
private const val CHAR_3 = '3'.code.toByte()
private const val CHAR_4 = '4'.code.toByte()
private const val CHAR_5 = '5'.code.toByte()
private const val CHAR_6 = '6'.code.toByte()
private const val CHAR_7 = '7'.code.toByte()
private const val CHAR_8 = '8'.code.toByte()
private const val CHAR_9 = '9'.code.toByte()
private const val CHAR_MINUS = '-'.code.toByte()
private const val CHAR_PLUS = '+'.code.toByte()
private const val CHAR_DOT = '.'.code.toByte()

// This template utilizes the One Definition Rule to create global arrays in a
// header. As seen in:
// https://github.com/chadaustin/sajson/blob/master/include/sajson.h
// bit 0 (1) - set if: plain ASCII string character
// bit 1 (2) - set if: whitespace
// bit 4 (0x10) - set if: 0-9 e E .
<span class="fc" id="L815">private val parseFlags = byteArrayOf(</span>
// 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
<span class="fc" id="L817">  0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 2, 0, 0, // 0</span>
<span class="fc" id="L818">  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 1</span>
<span class="fc" id="L819">  3, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0x11, 1, // 2</span>
<span class="fc" id="L820">  0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 1, 1, 1, 1, 1, 1, // 3</span>
<span class="fc" id="L821">  1, 1, 1, 1, 1, 0x11, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 4</span>
<span class="fc" id="L822">  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, // 5</span>
<span class="fc" id="L823">  1, 1, 1, 1, 1, 0x11, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 6</span>
<span class="fc" id="L824">  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 7</span>

  // 128-255
<span class="fc" id="L827">  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span>
<span class="fc" id="L828">  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span>
<span class="fc" id="L829">  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span>
<span class="fc" id="L830">  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span>
)
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>