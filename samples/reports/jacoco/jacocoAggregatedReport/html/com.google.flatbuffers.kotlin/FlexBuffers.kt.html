<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FlexBuffers.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">flatbuffers</a> &gt; <a href="index.source.html" class="el_package">com.google.flatbuffers.kotlin</a> &gt; <span class="el_source">FlexBuffers.kt</span></div><h1>FlexBuffers.kt</h1><pre class="source lang-java linenums">/*
 * Copyright 2021 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
@file:Suppress(&quot;NOTHING_TO_INLINE&quot;)
@file:JvmName(&quot;FlexBuffers&quot;)
package com.google.flatbuffers.kotlin

import kotlin.jvm.JvmName

/**
 * Reads a FlexBuffer message in ReadBuf and returns [Reference] to
 * the root element.
 * @param buffer ReadBuf containing FlexBuffer message
 * @return [Reference] to the root object
 */
public fun getRoot(buffer: ReadBuffer): Reference {
<span class="fc" id="L29">  var end: Int = buffer.limit</span>
<span class="fc" id="L30">  val byteWidth = buffer[--end].toInt()</span>
<span class="fc" id="L31">  val packetType = buffer[--end].toInt()</span>
<span class="fc" id="L32">  end -= byteWidth // The root data item.</span>
<span class="fc" id="L33">  return Reference(buffer, end, ByteWidth(byteWidth), packetType)</span>
}

/**
 * Represents an generic element in the buffer. It can be specialized into scalar types, using for example,
 * [Reference.toInt], or casted into Flexbuffer object types, like [Reference.toMap] or [Reference.toBlob].
 */
<span class="fc" id="L40">@Suppress(&quot;NOTHING_TO_INLINE&quot;)</span>
<span class="fc" id="L41">public class Reference internal constructor(</span>
<span class="fc" id="L42">  internal val buffer: ReadBuffer,</span>
<span class="fc" id="L43">  internal val end: Int,</span>
<span class="fc" id="L44">  internal val parentWidth: ByteWidth,</span>
<span class="fc" id="L45">  internal val byteWidth: ByteWidth,</span>
<span class="fc" id="L46">  internal val type: FlexBufferType</span>
) {

  internal constructor(bb: ReadBuffer, end: Int, parentWidth: ByteWidth, packedType: Int) :
<span class="fc" id="L50">    this(bb, end, parentWidth, ByteWidth(1 shl (packedType and 3)), FlexBufferType((packedType shr 2)))</span>

  /**
   * Checks whether the element is null type
   * @return true if null type
   */
<span class="fc" id="L56">  public val isNull: Boolean get() = type == T_NULL</span>

  /**
   * Checks whether the element is boolean type
   * @return true if boolean type
   */
<span class="fc" id="L62">  public val isBoolean: Boolean get() = type == T_BOOL</span>

  /**
   * Checks whether the element type is numeric (signed/unsigned integers and floats)
   * @return true if numeric type
   */
<span class="nc bnc" id="L68" title="All 4 branches missed.">  public val isNumeric: Boolean get() = isIntOrUInt || isFloat</span>

  /**
   * Checks whether the element type is signed or unsigned integers
   * @return true if an integer type
   */
<span class="nc bnc" id="L74" title="All 4 branches missed.">  public val isIntOrUInt: Boolean get() = isInt || isUInt</span>

  /**
   * Checks whether the element type is float
   * @return true if a float type
   */
<span class="nc bnc" id="L80" title="All 4 branches missed.">  public val isFloat: Boolean get() = type == T_FLOAT || type == T_INDIRECT_FLOAT</span>

  /**
   * Checks whether the element type is signed integer
   * @return true if a signed integer type
   */
<span class="nc bnc" id="L86" title="All 4 branches missed.">  public val isInt: Boolean get() = type == T_INT || type == T_INDIRECT_INT</span>

  /**
   * Checks whether the element type is signed integer
   * @return true if a signed integer type
   */
<span class="nc bnc" id="L92" title="All 4 branches missed.">  public val isUInt: Boolean get() = type == T_UINT || type == T_INDIRECT_UINT</span>

  /**
   * Checks whether the element type is string
   * @return true if a string type
   */
<span class="fc" id="L98">  public val isString: Boolean get() = type == T_STRING</span>

  /**
   * Checks whether the element type is key
   * @return true if a key type
   */
<span class="nc" id="L104">  public val isKey: Boolean get() = type == T_KEY</span>

  /**
   * Checks whether the element type is vector or a map. [TypedVector] are considered different types and will return
   * false.
   * @return true if a vector type
   */
<span class="pc bpc" id="L111" title="1 of 4 branches missed.">  public val isVector: Boolean get() = type == T_VECTOR || type == T_MAP</span>

  /**
   * Checks whether the element type is typed vector
   * @return true if a typed vector type
   */
<span class="fc" id="L117">  public val isTypedVector: Boolean get() = type.isTypedVector()</span>

  /**
   * Checks whether the element type is a map
   * @return true if a map type
   */
<span class="fc" id="L123">  public val isMap: Boolean get() = type == T_MAP</span>

  /**
   * Checks whether the element type is a blob
   * @return true if a blob type
   */
<span class="nc" id="L129">  public val isBlob: Boolean get() = type == T_BLOB</span>

  /**
   * Assumes [Reference] as a [Vector] and returns a [Reference] at index [index].
   */
<span class="fc" id="L134">  public operator fun get(index: Int): Reference = toVector()[index]</span>

  /**
   * Assumes [Reference] as a [Map] and returns a [Reference] for the value at key [key].
   */
<span class="fc" id="L139">  public operator fun get(key: String): Reference = toMap()[key]</span>

  /**
   * Returns element as a [Boolean].
   * If element type is not boolean, it will be cast to an integer and compared against 0
   * @return element as [Boolean]
   */
<span class="pc bpc" id="L146" title="3 of 4 branches missed.">  public fun toBoolean(): Boolean = if (isBoolean) buffer.getBoolean(end) else toUInt() != 0u</span>

  /**
   * Returns element as [Byte].
   *  For vector types, it will return size of the vector.
   *  For String type, it will be parsed as integer.
   *  Unsigned elements will become signed (with possible overflow).
   *  Float elements will be cast to a [Byte].
   * @return [Byte] or 0 if fail to convert element to integer.
   */
<span class="nc" id="L156">  public fun toByte(): Byte = toULong().toByte()</span>

  /**
   * Returns element as [Short].
   *  For vector types, it will return size of the vector.
   *  For String type, it will type to be parsed as integer.
   *  Unsigned elements will become signed (with possible overflow).
   *  Float elements will be cast to a [Short]
   * @return [Short] or 0 if fail to convert element to integer.
   */
<span class="nc" id="L166">  public fun toShort(): Short = toULong().toShort()</span>

  /**
   * Returns element as [Int].
   *  For vector types, it will return size of the vector.
   *  For String type, it will type to be parsed as integer.
   *  Unsigned elements will become signed (with possible overflow).
   *  Float elements will be cast to  [Int]
   * @return [Int] or 0 if fail to convert element to integer.
   */
<span class="fc" id="L176">  public fun toInt(): Int = toULong().toInt()</span>

  /**
   * Returns element as [Long].
   * For vector types, it will return size of the vector
   * For String type, it will type to be parsed as integer
   * Unsigned elements will become negative
   * Float elements will be cast to an integer
   * @return [Long] integer or 0 if fail to convert element to long.
   */
<span class="fc" id="L186">  public fun toLong(): Long = toULong().toLong()</span>

  /**
   * Returns element as [UByte].
   *  For vector types, it will return size of the vector.
   *  For String type, it will type to be parsed as integer.
   *  Negative elements will become unsigned counterpart.
   *  Float elements will be cast to a [UByte]
   * @return [UByte] or 0 if fail to convert element to integer.
   */
<span class="nc" id="L196">  public fun toUByte(): UByte = toULong().toUByte()</span>

  /**
   * Returns element as [UShort].
   *  For vector types, it will return size of the vector.
   *  For String type, it will type to be parsed as integer.
   *  Negative elements will become unsigned counterpart.
   *  Float elements will be cast to a [UShort]
   * @return [UShort] or 0 if fail to convert element to integer.
   */
<span class="nc" id="L206">  public fun toUShort(): UShort = toULong().toUShort()</span>

  /**
   * Returns element as [UInt].
   *  For vector types, it will return size of the vector.
   *  For String type, it will type to be parsed as integer.
   *  Negative elements will become unsigned counterpart.
   *  Float elements will be cast to a [UInt]
   * @return [UInt] or 0 if fail to convert element to integer.
   */
<span class="nc" id="L216">  public fun toUInt(): UInt = toULong().toUInt()</span>

  /**
   * Returns element as [ULong] integer.
   * For vector types, it will return size of the vector
   * For String type, it will type to be parsed as integer
   * Negative elements will become unsigned counterpart.
   * Float elements will be cast to an integer
   * @return [ULong] integer or 0 if fail to convert element to long.
   */
<span class="fc" id="L226">  public fun toULong(): ULong = resolve { pos: Int, width: ByteWidth -&gt;</span>
<span class="pc" id="L227">    when (type) {</span>
<span class="pc bpc" id="L228" title="13 of 20 branches missed.">      T_INDIRECT_INT, T_INDIRECT_UINT, T_INT, T_BOOL, T_UINT -&gt; buffer.readULong(pos, width)</span>
<span class="nc bnc" id="L229" title="All 8 branches missed.">      T_FLOAT, T_INDIRECT_FLOAT -&gt; buffer.readFloat(pos, width).toULong()</span>
<span class="nc bnc" id="L230" title="All 4 branches missed.">      T_STRING -&gt; toString().toULong()</span>
<span class="nc bnc" id="L231" title="All 4 branches missed.">      T_VECTOR -&gt; toVector().size.toULong()</span>
<span class="nc" id="L232">      else -&gt; 0UL</span>
    }
<span class="fc" id="L234">  }</span>

  /**
   * Returns element as [Float].
   * For vector types, it will return size of the vector
   * For String type, it will type to be parsed as [Float]
   * Float elements will be cast to an integer
   * @return [Float] integer or 0 if fail to convert element to long.
   */
<span class="nc" id="L243">  public fun toFloat(): Float = resolve { pos: Int, width: ByteWidth -&gt;</span>
<span class="nc" id="L244">    when (type) {</span>
<span class="nc bnc" id="L245" title="All 8 branches missed.">      T_INDIRECT_FLOAT, T_FLOAT -&gt; buffer.readFloat(pos, width).toFloat()</span>
<span class="nc bnc" id="L246" title="All 4 branches missed.">      T_INT -&gt; buffer.readInt(end, parentWidth).toFloat()</span>
<span class="nc bnc" id="L247" title="All 8 branches missed.">      T_UINT, T_BOOL -&gt; buffer.readUInt(end, parentWidth).toFloat()</span>
<span class="nc bnc" id="L248" title="All 4 branches missed.">      T_INDIRECT_INT -&gt; buffer.readInt(pos, width).toFloat()</span>
<span class="nc bnc" id="L249" title="All 4 branches missed.">      T_INDIRECT_UINT -&gt; buffer.readUInt(pos, width).toFloat()</span>
<span class="nc bnc" id="L250" title="All 4 branches missed.">      T_NULL -&gt; 0.0f</span>
<span class="nc bnc" id="L251" title="All 4 branches missed.">      T_STRING -&gt; toString().toFloat()</span>
<span class="nc bnc" id="L252" title="All 4 branches missed.">      T_VECTOR -&gt; toVector().size.toFloat()</span>
<span class="nc" id="L253">      else -&gt; 0f</span>
    }
<span class="nc" id="L255">  }</span>

  /**
   * Returns element as  [Double].
   * For vector types, it will return size of the vector
   * For String type, it will type to be parsed as [Double]
   * @return [Float] integer or 0 if fail to convert element to long.
   */
<span class="fc" id="L263">  public fun toDouble(): Double = resolve { pos: Int, width: ByteWidth -&gt;</span>
<span class="pc" id="L264">    when (type) {</span>
<span class="pc bpc" id="L265" title="6 of 8 branches missed.">      T_INDIRECT_FLOAT, T_FLOAT -&gt; buffer.readFloat(pos, width)</span>
<span class="nc bnc" id="L266" title="All 4 branches missed.">      T_INT -&gt; buffer.readInt(pos, width).toDouble()</span>
<span class="nc bnc" id="L267" title="All 8 branches missed.">      T_UINT, T_BOOL -&gt; buffer.readUInt(pos, width).toDouble()</span>
<span class="nc bnc" id="L268" title="All 4 branches missed.">      T_INDIRECT_INT -&gt; buffer.readInt(pos, width).toDouble()</span>
<span class="nc bnc" id="L269" title="All 4 branches missed.">      T_INDIRECT_UINT -&gt; buffer.readUInt(pos, width).toDouble()</span>
<span class="nc bnc" id="L270" title="All 4 branches missed.">      T_NULL -&gt; 0.0</span>
<span class="nc bnc" id="L271" title="All 4 branches missed.">      T_STRING -&gt; toString().toDouble()</span>
<span class="nc bnc" id="L272" title="All 4 branches missed.">      T_VECTOR -&gt; toVector().size.toDouble()</span>
<span class="nc" id="L273">      else -&gt; 0.0</span>
    }
<span class="fc" id="L275">  }</span>

  /**
   * Returns element as [Key] or invalid key.
   */
<span class="nc" id="L280">  public fun toKey(): Key = when (type) {</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">    T_KEY -&gt; Key(buffer, buffer.indirect(end, parentWidth))</span>
<span class="nc" id="L282">    else -&gt; nullKey()</span>
<span class="nc" id="L283">  }</span>
  /**
   * Returns element as a [String]
   * @return element as [String] or empty [String] if fail
   */
<span class="fc" id="L288">  override fun toString(): String = when (type) {</span>
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">    T_STRING -&gt; {</span>
<span class="fc" id="L290">      val start = buffer.indirect(end, parentWidth)</span>
<span class="fc" id="L291">      val size = buffer.readULong(start - byteWidth, byteWidth).toInt()</span>
<span class="fc" id="L292">      buffer.getString(start, size)</span>
    }
<span class="nc bnc" id="L294" title="All 2 branches missed.">    T_KEY -&gt; buffer.getKeyString(buffer.indirect(end, parentWidth))</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">    T_MAP -&gt; &quot;{ ${toMap().entries.joinToString(&quot;, &quot;) { &quot;${it.key}: ${it.value}&quot;}} }&quot;</span>
<span class="nc bnc" id="L296" title="All 8 branches missed.">    T_VECTOR, T_VECTOR_BOOL, T_VECTOR_FLOAT, T_VECTOR_INT,</span>
<span class="nc bnc" id="L297" title="All 6 branches missed.">    T_VECTOR_UINT, T_VECTOR_KEY, T_VECTOR_STRING_DEPRECATED -&gt; &quot;[ ${toVector().joinToString(&quot;, &quot;) { it.toString() }} ]&quot;</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">    T_INT -&gt; toLong().toString()</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">    T_UINT -&gt; toULong().toString()</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">    T_FLOAT -&gt; toDouble().toString()</span>
<span class="nc" id="L301">    else -&gt; &quot;${type.typeToString()}(end=$end)&quot;</span>
<span class="fc" id="L302">  }</span>

  /**
   * Returns element as a [ByteArray], converting scalar types when possible.
   * @return element as [ByteArray] or empty [ByteArray] if fail.
   */
  public fun toByteArray(): ByteArray {
<span class="nc" id="L309">    val vec = TypedVector(type.toElementTypedVector(), buffer, buffer.indirect(end, parentWidth), byteWidth)</span>
<span class="nc" id="L310">    return when (type) {</span>
<span class="nc bnc" id="L311" title="All 4 branches missed.">      T_VECTOR_INT -&gt; ByteArray(vec.size) { vec.getInt(it).toByte() }</span>
<span class="nc bnc" id="L312" title="All 4 branches missed.">      T_VECTOR_UINT -&gt; ByteArray(vec.size) { vec.getUInt(it).toByte() }</span>
<span class="nc bnc" id="L313" title="All 4 branches missed.">      T_VECTOR -&gt; ByteArray(vec.size) { vec[it].toByte() }</span>
<span class="nc bnc" id="L314" title="All 4 branches missed.">      T_VECTOR_FLOAT -&gt; ByteArray(vec.size) { vec.getFloat(it).toInt().toByte() }</span>
<span class="nc" id="L315">      else -&gt; ByteArray(0)</span>
    }
  }

  /**
   * Returns element as a [ByteArray], converting scalar types when possible.
   * @return element as [ByteArray] or empty [ByteArray] if fail.
   */
  public fun toShortArray(): ShortArray {
<span class="fc" id="L324">    val vec = TypedVector(type.toElementTypedVector(), buffer, buffer.indirect(end, parentWidth), byteWidth)</span>
<span class="fc" id="L325">    return when (type) {</span>
<span class="pc bpc" id="L326" title="1 of 4 branches missed.">      T_VECTOR_INT -&gt; ShortArray(vec.size) { vec.getInt(it).toShort() }</span>
<span class="nc bnc" id="L327" title="All 4 branches missed.">      T_VECTOR_UINT -&gt; ShortArray(vec.size) { vec.getUInt(it).toShort() }</span>
<span class="nc bnc" id="L328" title="All 4 branches missed.">      T_VECTOR -&gt; ShortArray(vec.size) { vec[it].toShort() }</span>
<span class="nc bnc" id="L329" title="All 4 branches missed.">      T_VECTOR_FLOAT -&gt; ShortArray(vec.size) { vec.getFloat(it).toInt().toShort() }</span>
<span class="nc" id="L330">      else -&gt; ShortArray(0)</span>
    }
  }

  /**
   * Returns element as a [IntArray], converting scalar types when possible.
   * @return element as [IntArray] or empty [IntArray] if fail.
   */
  public fun toIntArray(): IntArray {
<span class="fc" id="L339">    val vec = TypedVector(type.toElementTypedVector(), buffer, buffer.indirect(end, parentWidth), byteWidth)</span>
<span class="fc" id="L340">    return when (type) {</span>
<span class="pc bpc" id="L341" title="1 of 4 branches missed.">      T_VECTOR_INT -&gt; IntArray(vec.size) { vec.getInt(it).toInt() }</span>
<span class="nc bnc" id="L342" title="All 4 branches missed.">      T_VECTOR_UINT -&gt; IntArray(vec.size) { vec.getUInt(it).toInt() }</span>
<span class="nc bnc" id="L343" title="All 4 branches missed.">      T_VECTOR -&gt; IntArray(vec.size) { vec[it].toInt() }</span>
<span class="nc bnc" id="L344" title="All 4 branches missed.">      T_VECTOR_FLOAT -&gt; IntArray(vec.size) { vec.getFloat(it).toInt() }</span>
<span class="nc" id="L345">      else -&gt; IntArray(0)</span>
    }
  }

  /**
   * Returns element as a [LongArray], converting scalar types when possible.
   * @return element as [LongArray] or empty [LongArray] if fail.
   */
  public fun toLongArray(): LongArray {
<span class="fc" id="L354">    val vec = TypedVector(type.toElementTypedVector(), buffer, buffer.indirect(end, parentWidth), byteWidth)</span>
<span class="fc" id="L355">    return when (type) {</span>
<span class="pc bpc" id="L356" title="1 of 4 branches missed.">      T_VECTOR_INT -&gt; LongArray(vec.size) { vec.getInt(it) }</span>
<span class="nc bnc" id="L357" title="All 4 branches missed.">      T_VECTOR_UINT -&gt; LongArray(vec.size) { vec.getInt(it) }</span>
<span class="nc bnc" id="L358" title="All 4 branches missed.">      T_VECTOR -&gt; LongArray(vec.size) { vec[it].toLong() }</span>
<span class="nc bnc" id="L359" title="All 4 branches missed.">      T_VECTOR_FLOAT -&gt; LongArray(vec.size) { vec.getFloat(it).toLong() }</span>
<span class="nc" id="L360">      else -&gt; LongArray(0)</span>
    }
  }

  /**
   * Returns element as a [UByteArray], converting scalar types when possible.
   * @return element as [UByteArray] or empty [UByteArray] if fail.
   */
  public fun toUByteArray(): UByteArray {
<span class="nc" id="L369">    val vec = TypedVector(type.toElementTypedVector(), buffer, buffer.indirect(end, parentWidth), byteWidth)</span>
<span class="nc" id="L370">    return when (type) {</span>
<span class="nc bnc" id="L371" title="All 4 branches missed.">      T_VECTOR_INT -&gt; UByteArray(vec.size) { vec.getInt(it).toUByte() }</span>
<span class="nc bnc" id="L372" title="All 4 branches missed.">      T_VECTOR_UINT -&gt; UByteArray(vec.size) { vec.getUInt(it).toUByte() }</span>
<span class="nc bnc" id="L373" title="All 4 branches missed.">      T_VECTOR -&gt; UByteArray(vec.size) { vec[it].toUByte() }</span>
<span class="nc bnc" id="L374" title="All 4 branches missed.">      T_VECTOR_FLOAT -&gt; UByteArray(vec.size) { vec.getFloat(it).toInt().toUByte() }</span>
<span class="nc" id="L375">      else -&gt; UByteArray(0)</span>
    }
  }

  /**
   * Returns element as a [UIntArray], converting scalar types when possible.
   * @return element as [UIntArray] or empty [UIntArray] if fail.
   */
  public fun toUShortArray(): UShortArray {
<span class="nc" id="L384">    val vec = TypedVector(type.toElementTypedVector(), buffer, buffer.indirect(end, parentWidth), byteWidth)</span>
<span class="nc" id="L385">    return when (type) {</span>
<span class="nc bnc" id="L386" title="All 4 branches missed.">      T_VECTOR_INT -&gt; UShortArray(vec.size) { vec.getInt(it).toUShort() }</span>
<span class="nc bnc" id="L387" title="All 4 branches missed.">      T_VECTOR_UINT -&gt; UShortArray(vec.size) { vec.getUInt(it).toUShort() }</span>
<span class="nc bnc" id="L388" title="All 4 branches missed.">      T_VECTOR -&gt; UShortArray(vec.size) { vec[it].toUShort() }</span>
<span class="nc bnc" id="L389" title="All 4 branches missed.">      T_VECTOR_FLOAT -&gt; UShortArray(vec.size) { vec.getFloat(it).toUInt().toUShort() }</span>
<span class="nc" id="L390">      else -&gt; UShortArray(0)</span>
    }
  }

  /**
   * Returns element as a [UIntArray], converting scalar types when possible.
   * @return element as [UIntArray] or empty [UIntArray] if fail.
   */
  public fun toUIntArray(): UIntArray {
<span class="nc" id="L399">    val vec = TypedVector(type.toElementTypedVector(), buffer, buffer.indirect(end, parentWidth), byteWidth)</span>
<span class="nc" id="L400">    return when (type) {</span>
<span class="nc bnc" id="L401" title="All 4 branches missed.">      T_VECTOR_INT -&gt; UIntArray(vec.size) { vec.getInt(it).toUInt() }</span>
<span class="nc bnc" id="L402" title="All 4 branches missed.">      T_VECTOR_UINT -&gt; UIntArray(vec.size) { vec.getUInt(it).toUInt() }</span>
<span class="nc bnc" id="L403" title="All 4 branches missed.">      T_VECTOR -&gt; UIntArray(vec.size) { vec[it].toUInt() }</span>
<span class="nc bnc" id="L404" title="All 4 branches missed.">      T_VECTOR_FLOAT -&gt; UIntArray(vec.size) { vec.getFloat(it).toUInt() }</span>
<span class="nc" id="L405">      else -&gt; UIntArray(0)</span>
    }
  }

  /**
   * Returns element as a [ULongArray], converting scalar types when possible.
   * @return element as [ULongArray] or empty [ULongArray] if fail.
   */
  public fun toULongArray(): ULongArray {
<span class="nc" id="L414">    val vec = TypedVector(type.toElementTypedVector(), buffer, buffer.indirect(end, parentWidth), byteWidth)</span>
<span class="nc" id="L415">    return when (type) {</span>
<span class="nc bnc" id="L416" title="All 4 branches missed.">      T_VECTOR_INT -&gt; ULongArray(vec.size) { vec.getUInt(it) }</span>
<span class="nc bnc" id="L417" title="All 4 branches missed.">      T_VECTOR_UINT -&gt; ULongArray(vec.size) { vec.getUInt(it) }</span>
<span class="nc bnc" id="L418" title="All 4 branches missed.">      T_VECTOR -&gt; ULongArray(vec.size) { vec[it].toULong() }</span>
<span class="nc bnc" id="L419" title="All 4 branches missed.">      T_VECTOR_FLOAT -&gt; ULongArray(vec.size) { vec.getFloat(it).toULong() }</span>
<span class="nc" id="L420">      else -&gt; ULongArray(0)</span>
    }
  }

  /**
   * Returns element as a [FloatArray], converting scalar types when possible.
   * @return element as [FloatArray] or empty [FloatArray] if fail.
   */
  public fun toFloatArray(): FloatArray {
<span class="fc" id="L429">    val vec = TypedVector(type.toElementTypedVector(), buffer, buffer.indirect(end, parentWidth), byteWidth)</span>
<span class="fc" id="L430">    return when (type) {</span>
<span class="pc bpc" id="L431" title="1 of 4 branches missed.">      T_VECTOR_FLOAT -&gt; FloatArray(vec.size) { vec.getFloat(it).toFloat() }</span>
<span class="nc bnc" id="L432" title="All 4 branches missed.">      T_VECTOR_INT -&gt; FloatArray(vec.size) { vec.getInt(it).toFloat() }</span>
<span class="nc bnc" id="L433" title="All 4 branches missed.">      T_VECTOR_UINT -&gt; FloatArray(vec.size) { vec.getUInt(it).toFloat() }</span>
<span class="nc bnc" id="L434" title="All 4 branches missed.">      T_VECTOR -&gt; FloatArray(vec.size) { vec[it].toFloat() }</span>
<span class="nc" id="L435">      else -&gt; FloatArray(0)</span>
    }
  }

  /**
   * Returns element as a [DoubleArray], converting scalar types when possible.
   * @return element as [DoubleArray] or empty [DoubleArray] if fail.
   */
  public fun toDoubleArray(): DoubleArray {
<span class="fc" id="L444">    val vec = TypedVector(type.toElementTypedVector(), buffer, buffer.indirect(end, parentWidth), byteWidth)</span>
<span class="fc" id="L445">    return when (type) {</span>
<span class="pc bpc" id="L446" title="1 of 4 branches missed.">      T_VECTOR_FLOAT -&gt; DoubleArray(vec.size) { vec[it].toDouble() }</span>
<span class="nc bnc" id="L447" title="All 4 branches missed.">      T_VECTOR_INT -&gt; DoubleArray(vec.size) { vec[it].toDouble() }</span>
<span class="nc bnc" id="L448" title="All 4 branches missed.">      T_VECTOR_UINT -&gt; DoubleArray(vec.size) { vec[it].toDouble() }</span>
<span class="nc bnc" id="L449" title="All 4 branches missed.">      T_VECTOR -&gt; DoubleArray(vec.size) { vec[it].toDouble() }</span>
<span class="nc" id="L450">      else -&gt; DoubleArray(0)</span>
    }
  }

  /**
   * Returns element as a [Vector]
   * @return element as [Vector] or empty [Vector] if fail
   */
  public fun toVector(): Vector {
<span class="fc" id="L459">    return when {</span>
<span class="fc bfc" id="L460" title="All 2 branches covered.">      isVector -&gt; Vector(buffer, buffer.indirect(end, parentWidth), byteWidth)</span>
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">      isTypedVector -&gt; TypedVector(type.toElementTypedVector(), buffer, buffer.indirect(end, parentWidth), byteWidth)</span>
<span class="nc" id="L462">      else -&gt; emptyVector()</span>
    }
  }

  /**
   * Returns element as a [Blob]
   * @return element as [Blob] or empty [Blob] if fail
   */
  public fun toBlob(): Blob {
<span class="fc" id="L471">    return when (type) {</span>
<span class="pc bpc" id="L472" title="2 of 4 branches missed.">      T_BLOB, T_STRING -&gt; Blob(buffer, buffer.indirect(end, parentWidth), byteWidth)</span>
<span class="nc" id="L473">      else -&gt; emptyBlob()</span>
    }
  }

  /**
   * Returns element as a [Map].
   * @return element as [Map] or empty [Map] if fail
   */
<span class="fc" id="L481">  public fun toMap(): Map = when (type) {</span>
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">    T_MAP -&gt; Map(buffer, buffer.indirect(end, parentWidth), byteWidth)</span>
<span class="nc" id="L483">    else -&gt; emptyMap()</span>
<span class="fc" id="L484">  }</span>

  private inline fun &lt;T&gt; resolve(crossinline block: (pos: Int, width: ByteWidth) -&gt; T): T {
<span class="nc bnc" id="L487" title="All 2 branches missed.">    return if (type.isIndirectScalar()) {</span>
<span class="nc" id="L488">      block(buffer.indirect(end, byteWidth), byteWidth)</span>
    } else {
<span class="nc" id="L490">      block(end, parentWidth)</span>
    }
  }

  override fun equals(other: Any?): Boolean {
<span class="nc bnc" id="L495" title="All 2 branches missed.">    if (this === other) return true</span>
<span class="nc bnc" id="L496" title="All 4 branches missed.">    if (other == null || this::class != other::class) return false</span>
<span class="nc" id="L497">    other as Reference</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">    if (buffer != other.buffer ||</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">      end != other.end ||</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">      parentWidth != other.parentWidth ||</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">      byteWidth != other.byteWidth ||</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">      type != other.type</span>
<span class="nc" id="L503">    ) return false</span>
<span class="nc" id="L504">    return true</span>
  }

  override fun hashCode(): Int {
<span class="nc" id="L508">    var result = buffer.hashCode()</span>
<span class="nc" id="L509">    result = 31 * result + end</span>
<span class="nc" id="L510">    result = 31 * result + parentWidth.value</span>
<span class="nc" id="L511">    result = 31 * result + byteWidth.value</span>
<span class="nc" id="L512">    result = 31 * result + type.hashCode()</span>
<span class="nc" id="L513">    return result</span>
  }
}

/**
 * Represents any element that has a size property to it, like: [Map], [Vector] and [TypedVector].
 */
<span class="fc" id="L520">public open class Sized internal constructor(</span>
<span class="fc" id="L521">  public val buffer: ReadBuffer,</span>
<span class="fc" id="L522">  public val end: Int,</span>
<span class="fc" id="L523">  public val byteWidth: ByteWidth</span>
) {
<span class="fc" id="L525">  public open val size: Int = buffer.readSize(end, byteWidth)</span>
}

/**
 * Represent an array of bytes in the buffer.
 */
<span class="fc" id="L531">public open class Blob internal constructor(</span>
  buffer: ReadBuffer,
  end: Int,
  byteWidth: ByteWidth
<span class="fc" id="L535">) : Sized(buffer, end, byteWidth) {</span>
  /**
   * Return [Blob] as [ReadBuffer]
   * @return blob as [ReadBuffer]
   */
<span class="nc" id="L540">  public fun data(): ReadBuffer = buffer.slice(end, size)</span>

  /**
   * Copy [Blob] into a [ByteArray]
   * @return A [ByteArray] containing the blob data.
   */
  public fun toByteArray(): ByteArray {
<span class="fc" id="L547">    val result = ByteArray(size)</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">    for (i in 0 until size) {</span>
<span class="fc" id="L549">      result[i] = buffer[end + i]</span>
    }
<span class="fc" id="L551">    return result</span>
  }

  /**
   * Return individual byte at a given position
   * @param pos position of the byte to be read
   */
  public operator fun get(pos: Int): Byte {
<span class="pc bpc" id="L559" title="3 of 6 branches missed.">    if (pos !in 0..size) error(&quot;$pos index out of bounds. Should be in range 0..$size&quot;)</span>
<span class="fc" id="L560">    return buffer[end + pos]</span>
  }

<span class="nc" id="L563">  override fun toString(): String = buffer.getString(end, size)</span>
}

/**
 * [Vector] represents an array of elements in the buffer. The element can be of any type.
 */
<span class="fc" id="L569">public open class Vector internal constructor(</span>
  buffer: ReadBuffer,
  end: Int,
  byteWidth: ByteWidth
) : Collection&lt;Reference&gt;,
<span class="fc" id="L574">  Sized(buffer, end, byteWidth) {</span>

  /**
   * Returns a [Reference] from the [Vector] at position [index]. Returns a null reference
   * @param index position in the vector.
   * @return [Reference] for a key or a null [Reference] if not found.
   */
  public open operator fun get(index: Int): Reference {
<span class="pc bpc" id="L582" title="1 of 2 branches missed.">    if (index &gt;= size) return nullReference()</span>
<span class="fc" id="L583">    val packedType = buffer[(end + size * byteWidth.value + index)].toInt()</span>
<span class="fc" id="L584">    val objEnd = end + index * byteWidth</span>
<span class="fc" id="L585">    return Reference(buffer, objEnd, byteWidth, packedType)</span>
  }

  // overrides from Collection&lt;Reference&gt;

<span class="nc bnc" id="L590" title="All 6 branches missed.">  override fun contains(element: Reference): Boolean = find { it == element } != null</span>

  override fun containsAll(elements: Collection&lt;Reference&gt;): Boolean {
<span class="nc bnc" id="L593" title="All 2 branches missed.">    elements.forEach { if (!contains(it)) return false }</span>
<span class="nc" id="L594">    return true</span>
  }

<span class="nc bnc" id="L597" title="All 2 branches missed.">  override fun isEmpty(): Boolean = size == 0</span>

<span class="fc" id="L599">  override fun iterator(): Iterator&lt;Reference&gt; = object : Iterator&lt;Reference&gt; {</span>
<span class="nc" id="L600">    var position = 0</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">    override fun hasNext(): Boolean = position != size</span>
<span class="fc" id="L602">    override fun next(): Reference = get(position++)</span>
<span class="fc" id="L603">  }</span>
}

/**
 * [TypedVector] represents an array of scalar elements of the same type in the buffer.
 */
<span class="fc" id="L609">public open class TypedVector(</span>
<span class="fc" id="L610">  private val elementType: FlexBufferType,</span>
  buffer: ReadBuffer,
  end: Int,
  byteWidth: ByteWidth
<span class="fc" id="L614">) : Vector(buffer, end, byteWidth) {</span>

  /**
   * Returns a [Reference] from the [TypedVector] at position [index]. Returns a null reference
   * @param index position in the vector.
   * @return [Reference] for a key or a null [Reference] if not found.
   */
  override operator fun get(index: Int): Reference {
<span class="pc bpc" id="L622" title="1 of 2 branches missed.">    if (index &gt;= size) return nullReference()</span>
<span class="fc" id="L623">    val childPos: Int = end + index * byteWidth</span>
<span class="fc" id="L624">    return Reference(buffer, childPos, byteWidth, ByteWidth(1), elementType)</span>
  }

  private inline fun &lt;T&gt; resolveAt(index: Int, crossinline block: (Int, ByteWidth) -&gt; T): T {
<span class="nc" id="L628">    val childPos: Int = end + index * byteWidth</span>
<span class="nc" id="L629">    return block(childPos, byteWidth)</span>
  }

<span class="nc" id="L632">  internal fun getBoolean(index: Int): Boolean = resolveAt(index) { pos: Int, _: ByteWidth -&gt; buffer.getBoolean(pos) }</span>
<span class="fc" id="L633">  internal fun getInt(index: Int): Long = resolveAt(index) { pos: Int, width: ByteWidth -&gt; buffer.readLong(pos, width) }</span>
<span class="nc" id="L634">  internal fun getUInt(index: Int): ULong = resolveAt(index) { pos: Int, width: ByteWidth -&gt; buffer.readULong(pos, width) }</span>
<span class="fc" id="L635">  internal fun getFloat(index: Int): Double = resolveAt(index) { pos: Int, width: ByteWidth -&gt; buffer.readFloat(pos, width) }</span>
}

/**
 * Represents a key element in the buffer. Keys are
 * used to reference objects in a [Map]
 */
<span class="fc" id="L642">public data class Key(</span>
<span class="fc" id="L643">  public val buffer: ReadBuffer,</span>
<span class="fc" id="L644">  public val start: Int,</span>
<span class="pc" id="L645">  public val end: Int = buffer.findFirst(ZeroByte, start)</span>
) {

<span class="fc" id="L648">  val sizeInBytes: Int = end - start</span>

<span class="fc" id="L650">  private val codePoint = CharArray(2)</span>

  val sizeInChars: Int
    get() {
<span class="fc" id="L654">      var count = 0</span>
<span class="fc" id="L655">      var i = start</span>
<span class="fc bfc" id="L656" title="All 2 branches covered.">      while (i &lt; end) {</span>
<span class="fc" id="L657">        val size = codePointSizeInBytes(i)</span>
<span class="fc" id="L658">        i += size</span>
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">        count += if (size == 4) 2 else 1</span>
      }
<span class="fc" id="L661">      return count</span>
    }

  public operator fun get(index: Int): Char {
<span class="fc" id="L665">    var count = 0</span>
<span class="fc" id="L666">    var i = start</span>
<span class="fc" id="L667">    var size = 0</span>
    // we loop over the bytes to find the right position for the &quot;char&quot; at index i
<span class="pc bpc" id="L669" title="1 of 4 branches missed.">    while (i &lt; end &amp;&amp; count &lt; index) {</span>
<span class="fc" id="L670">      size = codePointSizeInBytes(i)</span>
<span class="fc" id="L671">      i += size</span>
      // 4 bytes utf8 are 2 chars wide, the rest is on char.
<span class="pc bpc" id="L673" title="1 of 2 branches missed.">      count += if (size == 4) 2 else 1</span>
    }
<span class="fc" id="L675">    return when {</span>
<span class="pc bpc" id="L676" title="1 of 2 branches missed.">      count == index -&gt; {</span>
<span class="fc" id="L677">        Utf8.decodeUtf8CodePoint(buffer, i, codePoint)</span>
<span class="fc" id="L678">        codePoint[0]</span>
      }
<span class="nc bnc" id="L680" title="All 4 branches missed.">      count == index + 1 &amp;&amp; size == 4 -&gt; {</span>
<span class="nc" id="L681">        Utf8.decodeUtf8CodePoint(buffer, i - size, codePoint)</span>
<span class="nc" id="L682">        codePoint[1]</span>
      }
<span class="nc" id="L684">      else -&gt; error(&quot;Invalid count=$count, index=$index&quot;)</span>
    }
  }

  private inline fun codePointSizeInBytes(pos: Int): Int {
<span class="nc" id="L689">    val b = buffer[pos]</span>
<span class="nc" id="L690">    return when {</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">      Utf8.isOneByte(b) -&gt; 1</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">      Utf8.isTwoBytes(b) -&gt; 2</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">      Utf8.isThreeBytes(b) -&gt; 3</span>
<span class="nc" id="L694">      else -&gt; 4</span>
    }
  }

<span class="pc bpc" id="L698" title="1 of 2 branches missed.">  override fun toString(): String = if (sizeInBytes &gt; 0) buffer.getString(start, sizeInBytes) else &quot;&quot;</span>

  /**
   * Checks whether Key is invalid or not.
   */
<span class="nc bnc" id="L703" title="All 2 branches missed.">  public fun isInvalid(): Boolean = sizeInBytes &lt;= 0</span>
<span class="fc" id="L704">}</span>

/**
 * A Map class that provide support to access Key-Value data from Flexbuffers.
 */
<span class="fc" id="L709">public class Map internal constructor(buffer: ReadBuffer, end: Int, byteWidth: ByteWidth) :</span>
<span class="fc" id="L710">  Sized(buffer, end, byteWidth),</span>
  kotlin.collections.Map&lt;Key, Reference&gt; {

  // used for accessing the key vector elements
  private var keyVectorEnd: Int
  private var keyVectorByteWidth: ByteWidth
<span class="fc" id="L716">  init {</span>
<span class="fc" id="L717">    val keysOffset = end - (3 * byteWidth) // 3 is number of prefixed fields</span>
<span class="fc" id="L718">    keyVectorEnd = buffer.indirect(keysOffset, byteWidth)</span>
<span class="fc" id="L719">    keyVectorByteWidth = ByteWidth(buffer.readInt(keysOffset + byteWidth, byteWidth))</span>
<span class="fc" id="L720">  }</span>

  /**
   * Returns a [Reference] from the [Map] at position [index]. Returns a null reference
   * @param index position in the map
   * @return [Reference] for a key or a null [Reference] if not found.
   */
  public operator fun get(index: Int): Reference {
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">    if (index &gt;= size) return nullReference()</span>
<span class="fc" id="L729">    val packedPos = end + size * byteWidth + index</span>
<span class="fc" id="L730">    val packedType = buffer[packedPos].toInt()</span>
<span class="fc" id="L731">    val objEnd = end + index * byteWidth</span>
<span class="fc" id="L732">    return Reference(buffer, objEnd, byteWidth, packedType)</span>
  }

  /**
   * Returns a [Reference] from the [Map] for a given [String] [key].
   * @param key access key to element on map
   * @return [Reference] for a key or a null [Reference] if not found.
   */
  public operator fun get(key: String): Reference {
<span class="fc" id="L741">    val index: Int = binarySearch(key)</span>
<span class="pc bpc" id="L742" title="1 of 6 branches missed.">    return if (index in 0 until size) {</span>
<span class="fc" id="L743">      get(index)</span>
<span class="fc" id="L744">    } else nullReference()</span>
  }

  /**
   * Returns a [Reference] from the [Map] for a given [Key] [key].
   * @param key access key to element on map
   * @return [Reference] for a key or a null [Reference] if not found.
   */
  override operator fun get(key: Key): Reference {
<span class="fc" id="L753">    val index = binarySearch(key)</span>
<span class="pc bpc" id="L754" title="3 of 6 branches missed.">    return if (index in 0 until size) {</span>
<span class="fc" id="L755">      get(index)</span>
<span class="nc" id="L756">    } else nullReference()</span>
  }

  /**
   * Checks whether the map contains a [key].
   * @param key [String]
   * @return true if key is found in the map, otherwise false.
   */
<span class="pc bpc" id="L764" title="1 of 2 branches missed.">  public operator fun contains(key: String): Boolean = binarySearch(key) &gt;= 0</span>

  /**
   * Returns a [Key] for a given position [index] in the [Map].
   * @param index of the key in the map
   * @return a Key for the given index. Out of bounds indexes returns invalid keys.
   */
  public fun keyAt(index: Int): Key {
<span class="fc" id="L772">    val childPos: Int = keyVectorEnd + index * keyVectorByteWidth</span>
<span class="fc" id="L773">    return Key(buffer, buffer.indirect(childPos, keyVectorByteWidth))</span>
  }

  /**
   * Returns a [Key] as [String] for a given position [index] in the [Map].
   * @param index of the key in the map
   * @return a Key for the given index. Out of bounds indexes returns empty string.
   */
  public fun keyAsString(index: Int): String {
<span class="fc" id="L782">    val childPos: Int = keyVectorEnd + index * keyVectorByteWidth</span>
<span class="fc" id="L783">    val start = buffer.indirect(childPos, keyVectorByteWidth)</span>
<span class="fc" id="L784">    val end = buffer.findFirst(ZeroByte, start)</span>
<span class="pc bpc" id="L785" title="1 of 2 branches missed.">    return if (end &gt; start) buffer.getString(start, end - start) else &quot;&quot;</span>
  }

  // Overrides from kotlin.collections.Map&lt;Key, Reference&gt;

<span class="nc" id="L790">  public data class Entry(override val key: Key, override val value: Reference) :</span>
    kotlin.collections.Map.Entry&lt;Key, Reference&gt;

  override val entries: Set&lt;kotlin.collections.Map.Entry&lt;Key, Reference&gt;&gt;
<span class="nc" id="L794">    get() = keys.map { Entry(it, get(it.toString())) }.toSet()</span>

  override val keys: Set&lt;Key&gt;
    get() {
<span class="fc" id="L798">      val set = LinkedHashSet&lt;Key&gt;(size)</span>
<span class="fc bfc" id="L799" title="All 2 branches covered.">      for (i in 0 until size) {</span>
<span class="fc" id="L800">        val key = keyAt(i)</span>
<span class="fc" id="L801">        set.add(key)</span>
      }
<span class="fc" id="L803">      return set</span>
    }

  /**
   * Returns a [Vector] for accessing all values in the [Map].
   * @return [Vector] of values.
   */
  override val values: Collection&lt;Reference&gt;
<span class="nc" id="L811">    get() = Vector(buffer, end, byteWidth)</span>

  override fun containsKey(key: Key): Boolean {
<span class="nc bnc" id="L814" title="All 2 branches missed.">    for (i in 0 until size) {</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">      if (key == keyAt(i))</span>
<span class="nc" id="L816">        return true</span>
    }
<span class="nc" id="L818">    return false</span>
  }

<span class="nc" id="L821">  override fun containsValue(value: Reference): Boolean = values.contains(value)</span>

<span class="nc bnc" id="L823" title="All 2 branches missed.">  override fun isEmpty(): Boolean = size == 0</span>

  // Performs a binary search on a key vector and return index of the key in key vector
<span class="fc" id="L826">  private fun binarySearch(searchedKey: String) = binarySearch { compareCharSequence(it, searchedKey) }</span>
  // Performs a binary search on a key vector and return index of the key in key vector
<span class="fc" id="L828">  private fun binarySearch(key: Key): Int = binarySearch { compareKeys(it, key.start) }</span>

  private inline fun binarySearch(crossinline comparisonBlock: (Int) -&gt; Int): Int {
<span class="nc" id="L831">    var low = 0</span>
<span class="nc" id="L832">    var high = size - 1</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">    while (low &lt;= high) {</span>
<span class="nc" id="L834">      val mid = low + high ushr 1</span>
<span class="nc" id="L835">      val keyPos: Int = buffer.indirect(keyVectorEnd + mid * keyVectorByteWidth, keyVectorByteWidth)</span>
<span class="nc" id="L836">      val cmp: Int = comparisonBlock(keyPos)</span>
<span class="nc bnc" id="L837" title="All 4 branches missed.">      if (cmp &lt; 0) low = mid + 1 else if (cmp &gt; 0) high = mid - 1 else return mid // key found</span>
    }
<span class="nc" id="L839">    return -(low + 1) // key not found</span>
  }

  // compares a CharSequence against a T_KEY
  private fun compareKeys(start: Int, other: Int): Int {
<span class="fc" id="L844">    var bufferPos = start</span>
<span class="fc" id="L845">    var otherPos = other</span>
<span class="fc" id="L846">    val limit: Int = buffer.limit</span>
<span class="fc" id="L847">    var c1: Byte = ZeroByte</span>
<span class="fc" id="L848">    var c2: Byte = ZeroByte</span>
<span class="pc bpc" id="L849" title="1 of 2 branches missed.">    while (otherPos &lt; limit) {</span>
<span class="fc" id="L850">      c1 = buffer[bufferPos++]</span>
<span class="fc" id="L851">      c2 = buffer[otherPos++]</span>
<span class="fc" id="L852">      when {</span>
<span class="fc bfc" id="L853" title="All 2 branches covered.">        c1 == ZeroByte -&gt; return c1 - c2</span>
<span class="fc bfc" id="L854" title="All 2 branches covered.">        c1 != c2 -&gt; return c1 - c2</span>
      }
    }
<span class="nc" id="L857">    return c1 - c2</span>
  }

  // compares a CharSequence against a [CharSequence]
  private fun compareCharSequence(start: Int, other: CharSequence): Int {
<span class="fc" id="L862">    var bufferPos = start</span>
<span class="fc" id="L863">    var otherPos = 0</span>
<span class="fc" id="L864">    val limit: Int = buffer.limit</span>
<span class="fc" id="L865">    val otherLimit = other.length</span>
    // special loop for ASCII characters. Most keys should be ASCII only, so this
    // loop should be optimized for that.
    // breaks if a multi-byte character is found
<span class="fc bfc" id="L869" title="All 2 branches covered.">    while (otherPos &lt; otherLimit) {</span>
<span class="fc" id="L870">      val c2 = other[otherPos]</span>
      // not a single byte codepoint
<span class="pc bpc" id="L872" title="1 of 2 branches missed.">      if (c2.code &gt;= 0x80) {</span>
<span class="nc" id="L873">        break</span>
      }
<span class="fc" id="L875">      val b: Byte = buffer[bufferPos]</span>
<span class="fc" id="L876">      when {</span>
<span class="fc bfc" id="L877" title="All 2 branches covered.">        b == ZeroByte -&gt; return -c2.code</span>
<span class="pc bpc" id="L878" title="1 of 2 branches missed.">        b &lt; 0                 -&gt; break</span>
<span class="fc bfc" id="L879" title="All 2 branches covered.">        b != c2.code.toByte() -&gt; return b - c2.code.toByte()</span>
      }
<span class="fc" id="L881">      ++bufferPos</span>
<span class="fc" id="L882">      ++otherPos</span>
    }
<span class="pc bpc" id="L884" title="1 of 2 branches missed.">    if (bufferPos &lt; limit)</span>
<span class="fc" id="L885">      return 0</span>

<span class="nc" id="L887">    val comparisonBuffer = ByteArray(4)</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">    while (bufferPos &lt; limit) {</span>
<span class="nc" id="L889">      val sizeInBuff = Utf8.encodeUtf8CodePoint(other, otherPos, comparisonBuffer)</span>
<span class="nc bnc" id="L890" title="All 2 branches missed.">      if (sizeInBuff == 0) {</span>
<span class="nc" id="L891">        return buffer[bufferPos].toInt()</span>
      }
<span class="nc bnc" id="L893" title="All 2 branches missed.">      for (i in 0 until sizeInBuff) {</span>
<span class="nc" id="L894">        val bufferByte: Byte = buffer[bufferPos++]</span>
<span class="nc" id="L895">        val otherByte: Byte = comparisonBuffer[i]</span>
<span class="nc" id="L896">        when {</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">          bufferByte == ZeroByte -&gt; return -otherByte</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">          bufferByte != otherByte -&gt; return bufferByte - otherByte</span>
        }
      }
<span class="nc bnc" id="L901" title="All 2 branches missed.">      otherPos += if (sizeInBuff == 4) 2 else 1</span>
    }
<span class="nc" id="L903">    return 0</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>