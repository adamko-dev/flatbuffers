<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Buffers.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">flatbuffers</a> &gt; <a href="index.source.html" class="el_package">com.google.flatbuffers.kotlin</a> &gt; <span class="el_source">Buffers.kt</span></div><h1>Buffers.kt</h1><pre class="source lang-java linenums">/*
 * Copyright 2021 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.flatbuffers.kotlin

import kotlin.math.max
import kotlin.math.min

/**
 * Represent a chunk of data, where FlexBuffers will be read from.
 */
public interface ReadBuffer {

  /**
   * Scan through the buffer for first byte matching value.
   * @param value to be match
   * @param start inclusive initial position to start searching
   * @param end exclusive final position of the search
   * @return position of a match or -1
   */
<span class="fc" id="L33">  public fun findFirst(value: Byte, start: Int, end: Int = limit): Int</span>

  /**
   * Read boolean from the buffer. Booleans as stored as a single byte
   * @param index position of the element in [ReadBuffer]
   * @return [Boolean] element
   */
  public fun getBoolean(index: Int): Boolean

  /**
   * Read a [Byte] from the buffer.
   * @param index position of the element in [ReadBuffer]
   * @return a byte
   */
  public operator fun get(index: Int): Byte

  /**
   * Read a [UByte] from the buffer.
   * @param index position of the element in [ReadBuffer]
   * @return a [UByte]
   */
  public fun getUByte(index: Int): UByte

  /**
   * Read a [Short] from the buffer.
   * @param index position of the element in [ReadBuffer]
   * @return a [Short]
   */
  public fun getShort(index: Int): Short

  /**
   * Read a [UShort] from the buffer.
   * @param index position of the element in [ReadBuffer]
   * @return a [UShort]
   */
  public fun getUShort(index: Int): UShort

  /**
   * Read a [Int] from the buffer.
   * @param index position of the element in [ReadBuffer]
   * @return an [Int]
   */
  public fun getInt(index: Int): Int

  /**
   * Read a [UInt] from the buffer.
   * @param index position of the element in [ReadBuffer]
   * @return an [UInt]
   */
  public fun getUInt(index: Int): UInt

  /**
   * Read a [Long] from the buffer.
   * @param index position of the element in [ReadBuffer]
   * @return a [Long]
   */
  public fun getLong(index: Int): Long

  /**
   * Read a [ULong] from the buffer.
   * @param index position of the element in [ReadBuffer]
   * @return a [ULong]
   */
  public fun getULong(index: Int): ULong

  /**
   * Read a 32-bit float from the buffer.
   * @param index position of the element in [ReadBuffer]
   * @return a float
   */
  public fun getFloat(index: Int): Float

  /**
   * Read a 64-bit float from the buffer.
   * @param index position of the element in [ReadBuffer]
   * @return a double
   */
  public fun getDouble(index: Int): Double

  /**
   * Read an UTF-8 string from the buffer.
   * @param start initial element of the string
   * @param size size of the string in bytes.
   * @return a `String`
   */
  public fun getString(start: Int, size: Int): String

  /**
   * Expose [ReadBuffer] as an array of bytes.
   * This method is meant to be as efficient as possible, so for a array-backed [ReadBuffer], it should
   * return its own internal data. In case access to internal data is not possible,
   * a copy of the data into an array of bytes might occur.
   * @return [ReadBuffer] as an array of bytes
   */
  public fun data(): ByteArray

  /**
   * Creates a new [ReadBuffer] point to a region of the current buffer, starting at [start] with size [size].
   * @param start starting position of the [ReadBuffer]
   * @param size in bytes of the [ReadBuffer]
   * @return [ReadBuffer] slice.
   */
  public fun slice(start: Int, size: Int): ReadBuffer

  /**
   * Defines the size of the message in the buffer. It also determines last position that buffer
   * can be read. Last byte to be accessed is in position `limit() -1`.
   * @return indicate last position
   */
  public val limit: Int
}

/**
 * Interface to represent a read-write buffers. This interface will be used to access and write FlexBuffer messages.
 */
public interface ReadWriteBuffer : ReadBuffer {
  /**
   * Clears (resets) the buffer so that it can be reused. Write position will be set to the start.
   */
  public fun clear()

  /**
   * Put a [Boolean] into the buffer at [writePosition] . Booleans as stored as single byte.
   * Write position will be incremented.
   * @return [Boolean] element
   */
  public fun put(value: Boolean)

  /**
   * Put an array of bytes into the buffer at [writePosition]. Write position will be incremented.
   * @param value the data to be copied
   * @param start initial position on value to be copied
   * @param length amount of bytes to be copied
   */
  public fun put(value: ByteArray, start: Int, length: Int)

  /**
   * Write a [Byte] into the buffer at [writePosition]. Write position will be incremented.
   */
  public fun put(value: Byte)

  /**
   * Write a [UByte] into the buffer at [writePosition]. Write position will be incremented.
   */
  public fun put(value: UByte)

  /**
   * Write a [Short] into in the buffer at [writePosition]. Write position will be incremented.
   */
  public fun put(value: Short)

  /**
   * Writea [UShort] into in the buffer at [writePosition]. Write position will be incremented.
   */
  public fun put(value: UShort)

  /**
   * Write a [Int] in the buffer at [writePosition]. Write position will be incremented.
   */
  public fun put(value: Int)

  /**
   * Write a [UInt] into in the buffer at [writePosition]. Write position will be incremented.
   */
  public fun put(value: UInt)

  /**
   * Write a [Long] into in the buffer at [writePosition]. Write position will be
   * incremented.
   */
  public fun put(value: Long)

  /**
   * Write a [ULong] into in the buffer at [writePosition]. Write position will be
   * incremented.
   */
  public fun put(value: ULong)

  /**
   * Write a 32-bit [Float] into the buffer at [writePosition]. Write position will be
   * incremented.
   */
  public fun put(value: Float)

  /**
   * Write a 64-bit [Double] into the buffer at [writePosition]. Write position will be
   * incremented.
   */
  public fun put(value: Double)

  /**
   * Write a [String] encoded as UTF-8 into the buffer at [writePosition]. Write position will be incremented.
   * @return size in bytes of the encoded string
   */
<span class="fc" id="L227">  public fun put(value: String, encodedLength: Int = -1): Int</span>

  /**
   * Write an array of bytes into the buffer.
   * @param dstIndex initial position where [src] will be copied into.
   * @param src the data to be copied.
   * @param srcStart initial position on [src] that will be copied.
   * @param srcLength amount of bytes to be copied
   */
  public operator fun set(dstIndex: Int, src: ByteArray, srcStart: Int, srcLength: Int)

  /**
   * Write [Boolean] into a given position [index] on the buffer. Booleans as stored as single byte.
   * @param index position of the element in buffer
   */
  public operator fun set(index: Int, value: Boolean)

  /**
   * Write [Byte] into a given position [index] on the buffer.
   * @param index position of the element in the buffer
   */
  public operator fun set(index: Int, value: Byte)

  /**
   * Write [UByte] into a given position [index] on the buffer.
   * @param index position of the element in the buffer
   */
  public operator fun set(index: Int, value: UByte)

  /**
   Short
   * @param index position of the element in [ReadBuffer]
   */
  public fun set(index: Int, value: Short)

  /**
   * Write [UShort] into a given position [index] on the buffer.
   * @param index position of the element in [ReadBuffer]
   */
  public fun set(index: Int, value: UShort)

  /**
   * Write [Int] into a given position [index] on the buffer.
   * @param index position of the element in [ReadBuffer]
   */
  public fun set(index: Int, value: Int)

  /**
   * Write [UInt] into a given position [index] on the buffer.
   * @param index position of the element in [ReadBuffer]
   */
  public fun set(index: Int, value: UInt)

  /**
   * Write [Long] into a given position [index] on the buffer.
   * @param index position of the element in [ReadBuffer]
   */
  public fun set(index: Int, value: Long)

  /**
   * Write [ULong] into a given position [index] on the buffer.
   * @param index position of the element in [ReadBuffer]
   */
  public fun set(index: Int, value: ULong)

  /**
   * Write [Float] into a given position [index] on the buffer.
   * @param index position of the element in [ReadBuffer]
   */
  public fun set(index: Int, value: Float)

  /**
   * Write [Double] into a given position [index] on the buffer.
   * @param index position of the element in [ReadBuffer]
   */
  public fun set(index: Int, value: Double)

  /**
   * Current position of the buffer to be written. It will be automatically updated on [put] operations.
   */
  public var writePosition: Int

  /**
   * Defines the size of the message in the buffer. It also determines last position that buffer
   * can be read or write. Last byte to be accessed is in position `limit() -1`.
   * @return indicate last position
   */
  override val limit: Int

  /**
   * Request capacity of the buffer. In case buffer is already larger
   * than the requested, this method will just return true. Otherwise
   * It might try to resize the buffer. In case of being unable to allocate
   * enough memory, an exception will be thrown.
   */
  public fun requestCapacity(capacity: Int)
}

<span class="fc" id="L325">public open class ArrayReadBuffer(protected var buffer: ByteArray, override val limit: Int = buffer.size) : ReadBuffer {</span>

  override fun findFirst(value: Byte, start: Int, end: Int): Int {
<span class="fc" id="L328">    val e = min(end, limit)</span>
<span class="fc" id="L329">    val s = max(0, start)</span>
<span class="fc bfc" id="L330" title="All 4 branches covered.">    for (i in s until e) if (buffer[i] == value) return i</span>
<span class="fc" id="L331">    return -1</span>
  }

<span class="fc bfc" id="L334" title="All 2 branches covered.">  override fun getBoolean(index: Int): Boolean = buffer[index] != 0.toByte()</span>

<span class="fc" id="L336">  override operator fun get(index: Int): Byte = buffer[index]</span>

<span class="fc" id="L338">  override fun getUByte(index: Int): UByte = buffer.getUByte(index)</span>

<span class="nc" id="L340">  override fun getShort(index: Int): Short = buffer.getShort(index)</span>

<span class="fc" id="L342">  override fun getUShort(index: Int): UShort = buffer.getUShort(index)</span>

<span class="fc" id="L344">  override fun getInt(index: Int): Int = buffer.getInt(index)</span>

<span class="fc" id="L346">  override fun getUInt(index: Int): UInt = buffer.getUInt(index)</span>

<span class="nc" id="L348">  override fun getLong(index: Int): Long = buffer.getLong(index)</span>

<span class="fc" id="L350">  override fun getULong(index: Int): ULong = buffer.getULong(index)</span>

<span class="fc" id="L352">  override fun getFloat(index: Int): Float = buffer.getFloat(index)</span>

<span class="fc" id="L354">  override fun getDouble(index: Int): Double = buffer.getDouble(index)</span>

<span class="fc" id="L356">  override fun getString(start: Int, size: Int): String = buffer.decodeToString(start, start + size)</span>

<span class="fc" id="L358">  override fun data(): ByteArray = buffer</span>

<span class="nc" id="L360">  override fun slice(start: Int, size: Int): ReadBuffer = ArrayReadBuffer(buffer, limit)</span>
<span class="fc" id="L361">}</span>
/**
 * Implements [ReadWriteBuffer] using [ByteArray] as backing buffer. Using array of bytes are
 * usually faster than `ByteBuffer`.
 *
 * This class is not thread-safe, meaning that it must operate on a single thread.
 * Operating from multiple thread leads to undefined behavior
 *
 * All operations assume Little Endian byte order.
 */
<span class="fc" id="L371">public class ArrayReadWriteBuffer(</span>
  buffer: ByteArray,
<span class="fc" id="L373">  override var writePosition: Int = 0</span>
<span class="fc" id="L374">) : ArrayReadBuffer(buffer, writePosition), ReadWriteBuffer {</span>

<span class="pc" id="L376">  public constructor(initialCapacity: Int = 10) : this(ByteArray(initialCapacity))</span>

<span class="fc" id="L378">  override val limit: Int get() = writePosition</span>

<span class="fc" id="L380">  override fun clear(): Unit = run { writePosition = 0 }</span>

  override fun put(value: Boolean) {
<span class="nc" id="L383">    set(writePosition, value)</span>
<span class="nc" id="L384">    writePosition++</span>
<span class="nc" id="L385">  }</span>

  override fun put(value: ByteArray, start: Int, length: Int) {
<span class="fc" id="L388">    set(writePosition, value, start, length)</span>
<span class="fc" id="L389">    writePosition += length</span>
<span class="fc" id="L390">  }</span>

  override fun put(value: Byte) {
<span class="fc" id="L393">    set(writePosition, value)</span>
<span class="fc" id="L394">    writePosition++</span>
<span class="fc" id="L395">  }</span>

  override fun put(value: UByte) {
<span class="fc" id="L398">    set(writePosition, value)</span>
<span class="fc" id="L399">    writePosition++</span>
<span class="fc" id="L400">  }</span>

  override fun put(value: Short) {
<span class="nc" id="L403">    set(writePosition, value)</span>
<span class="nc" id="L404">    writePosition += 2</span>
<span class="nc" id="L405">  }</span>

  override fun put(value: UShort) {
<span class="fc" id="L408">    set(writePosition, value)</span>
<span class="fc" id="L409">    writePosition += 2</span>
<span class="fc" id="L410">  }</span>

  override fun put(value: Int) {
<span class="nc" id="L413">    set(writePosition, value)</span>
<span class="nc" id="L414">    writePosition += 4</span>
<span class="nc" id="L415">  }</span>

  override fun put(value: UInt) {
<span class="fc" id="L418">    set(writePosition, value)</span>
<span class="fc" id="L419">    writePosition += 4</span>
<span class="fc" id="L420">  }</span>

  override fun put(value: Long) {
<span class="nc" id="L423">    set(writePosition, value)</span>
<span class="nc" id="L424">    writePosition += 8</span>
<span class="nc" id="L425">  }</span>

  override fun put(value: ULong) {
<span class="fc" id="L428">    set(writePosition, value)</span>
<span class="fc" id="L429">    writePosition += 8</span>
<span class="fc" id="L430">  }</span>

  override fun put(value: Float) {
<span class="fc" id="L433">    set(writePosition, value)</span>
<span class="fc" id="L434">    writePosition += 4</span>
<span class="fc" id="L435">  }</span>

  override fun put(value: Double) {
<span class="fc" id="L438">    set(writePosition, value)</span>
<span class="fc" id="L439">    writePosition += 8</span>
<span class="fc" id="L440">  }</span>

  override fun put(value: String, encodedLength: Int): Int {
<span class="fc bfc" id="L443" title="All 2 branches covered.">    val length = if (encodedLength != -1) encodedLength else Utf8.encodedLength(value)</span>
<span class="fc" id="L444">    withCapacity(writePosition + length) {</span>
<span class="fc" id="L445">      writePosition = setString(writePosition, value)</span>
<span class="fc" id="L446">    }</span>
<span class="fc" id="L447">    return length</span>
  }

  override fun set(index: Int, value: Boolean) {
<span class="nc bnc" id="L451" title="All 2 branches missed.">    set(index, if (value) 1.toByte() else 0.toByte())</span>
<span class="nc" id="L452">  }</span>

  override operator fun set(dstIndex: Int, src: ByteArray, srcStart: Int, srcLength: Int) {
<span class="fc" id="L455">    withCapacity(dstIndex + (srcLength + srcStart)) {</span>
<span class="fc" id="L456">      src.copyInto(buffer, dstIndex, srcStart, srcStart + srcLength)</span>
<span class="fc" id="L457">    }</span>
<span class="fc" id="L458">  }</span>

<span class="fc" id="L460">  override operator fun set(index: Int, value: Byte): Unit = withCapacity(index + 1) { set(index, value) }</span>
<span class="fc" id="L461">  override operator fun set(index: Int, value: UByte): Unit = withCapacity(index + 1) { setUByte(index, value) }</span>
<span class="nc" id="L462">  override operator fun set(index: Int, value: Short): Unit = withCapacity(index + 2) { setShort(index, value) }</span>
<span class="fc" id="L463">  override operator fun set(index: Int, value: UShort): Unit = withCapacity(index + 2) { setUShort(index, value) }</span>
<span class="nc" id="L464">  override operator fun set(index: Int, value: Int): Unit = withCapacity(index + 4) { setInt(index, value) }</span>
<span class="fc" id="L465">  override operator fun set(index: Int, value: UInt): Unit = withCapacity(index + 4) { setUInt(index, value) }</span>
<span class="nc" id="L466">  override operator fun set(index: Int, value: Long): Unit = withCapacity(index + 8) { setLong(index, value) }</span>
<span class="fc" id="L467">  override operator fun set(index: Int, value: ULong): Unit = withCapacity(index + 8) { setULong(index, value) }</span>
<span class="fc" id="L468">  override operator fun set(index: Int, value: Float): Unit = withCapacity(index + 4) { setFloat(index, value) }</span>
<span class="fc" id="L469">  override operator fun set(index: Int, value: Double): Unit = withCapacity(index + 8) { setDouble(index, value) }</span>

  override fun requestCapacity(capacity: Int) {
<span class="pc bpc" id="L472" title="1 of 2 branches missed.">    if (capacity &lt; 0) error(&quot;Capacity may not be negative (likely a previous int overflow)&quot;)</span>

<span class="fc bfc" id="L474" title="All 2 branches covered.">    if (buffer.size &gt;= capacity) return</span>
    // implemented in the same growing fashion as ArrayList
<span class="fc" id="L476">    val oldCapacity = buffer.size</span>
<span class="fc" id="L477">    var newCapacity = oldCapacity + (oldCapacity shr 1)</span>
<span class="fc bfc" id="L478" title="All 2 branches covered.">    if (newCapacity &lt; capacity) { // Note: this also catches newCapacity int overflow</span>
<span class="fc" id="L479">      newCapacity = capacity</span>
    }
<span class="fc" id="L481">    buffer = buffer.copyOf(newCapacity)</span>
<span class="fc" id="L482">  }</span>

  private inline fun withCapacity(size: Int, crossinline action: ByteArray.() -&gt; Unit) {
<span class="nc" id="L485">    requestCapacity(size)</span>
<span class="nc" id="L486">    buffer.action()</span>
<span class="nc" id="L487">  }</span>
<span class="fc" id="L488">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>